(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[854],{3905:function(e,t,n){"use strict";n.d(t,{kt:function(){return m}});var i=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,i,r=function(e,t){if(null==e)return{};var n,i,r={},a=Object.keys(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=i.createContext({}),c=function(e){var t=i.useContext(s),n=t;return e&&(n="function"===typeof e?e(t):o(o({},t),e)),n},u={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},p=i.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),m=c(n),h=r,f=m["".concat(s,".").concat(h)]||m[h]||u[h]||a;return n?i.createElement(f,o(o({ref:t},p),{},{components:n})):i.createElement(f,o({ref:t},p))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"===typeof e||r){var a=n.length,o=new Array(a);o[0]=p;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"===typeof e?e:r,o[1]=l;for(var c=2;c<a;c++)o[c]=n[c];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}p.displayName="MDXCreateElement"},5855:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/posts/knapsack",function(){return n(6667)}])},6667:function(e,t,n){"use strict";n.r(t),n.d(t,{default:function(){return s}});n(7294);var i=n(3905),r=n(9008);function a(e,t){if(null==e)return{};var n,i,r=function(e,t){if(null==e)return{};var n,i,r={},a=Object.keys(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var o={},l=function(e){var t=e.children;return(0,i.kt)("main",{className:"md:w-3/5 text-lg mr-auto ml-auto mt-20 pb-20 article"},t)};function s(e){var t=e.components,n=a(e,["components"]);return(0,i.kt)(l,Object.assign({},o,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)(r.default,{mdxType:"Head"},(0,i.kt)("script",{defer:!0},"hljs.highlightAll();"),(0,i.kt)("title",null,"Knapsack problem and weighted median"),(0,i.kt)("meta",{name:"Description",content:"Knapsack problem and weighted median"})),(0,i.kt)("h1",null,"Knapsack problem and weighted median"),(0,i.kt)("figure",{className:"mt-10"},(0,i.kt)("img",{className:"mx-auto",src:"/backpack.webp",width:"60%",height:"60%"})),(0,i.kt)("p",null,"Knapsack problem is a leading example for using the dynamic programming. There are many variants of which two are most prominent ",(0,i.kt)("b",null,"fractional")," and ",(0,i.kt)("b",null,"discrete"),".\nI will shortly discuss both, but concentrate on the fractional one because the link between weighted median and it's solution\nis really interesting."),(0,i.kt)("h3",null,"Dynamic programming and discrete case"),(0,i.kt)("p",null,"The problem is like this: "),(0,i.kt)("pre",{className:"mt-8"},(0,i.kt)("code",{className:"language-markdown"},"\nGiven 1..n items each with cost c[i] and weight w[i], fill in the backpack with weight W so that\nthe value of the packed items is maximized.\n")),(0,i.kt)("p",null,"The naive way seems to be using greedy algorithm as follows: sort the items so they are descending by\ncost, fill in the backpack taking items in order until we reach capacity. But it's wrong. It's because\nthe last item can not fit in the backpack in whole leaving empty space in the backpack. And this space\nlowers the overall efficiency of the solution."),(0,i.kt)("p",null,"This problem is solvable with dynamic programming. It is because it has ",(0,i.kt)("b",null,"optimal subproblems property"),".\nFor the optimal solution W2 which is subsolution W1 plus optimal item w","[k]"," in this step the W1 subsolution is\nalso optimal. Given this we can implement O(nW) solution with dynamic programming, computing:"),(0,i.kt)("pre",{className:"mt-8"},(0,i.kt)("code",{className:"language-markdown"},"\nS[W] = max [S[W-w[i]] + weight[i]]\n")),(0,i.kt)("h3",null,"Greedy approach and fractional case"),(0,i.kt)("p",null,"This is the main part of the article. In this case we can cut the items into pieces to fill in the backpack at full.\nThis time we can solve it greedily because at all times we have backback filled to it's full. But more suitable\nproblem statement would be as follows."),(0,i.kt)("pre",{className:"mt-8"},(0,i.kt)("code",{className:"language-markdown"},"\nGiven 1..n liquids with density c[i] and velocity v[i] fill in the bucket of velocity V so that the weight\nof the mixed liquids is maximized. \n")),(0,i.kt)("p",null,"To obvious approach is to sort the liquids by density and take them one by one until V is reached. But this\nsolution takes O(nlogn) time because of sorting. Can we do it faster? Yes!"),(0,i.kt)("p",null,"With the help of Quick Select we can do this in O(n) time. The algorithm is as follows:"),(0,i.kt)("pre",{className:"mt-8"},(0,i.kt)("code",{className:"language-markdown"},"\nS = (sum of all weights) - V\n\n\nSELECT(left, right, S)\n    pivot <- choose random index in range [left, right]\n    i <- PARTITION(left, right, pivot)\n    L <- sum of w[i] in partition left to the i\n    R <- sum of w[i] in partition right to the i\n\n    if L > S:\n        SELECT(left, i, S)\n    else if R > S:\n        SELECT(i+1, right, S-L-w[i])\n\nPARTITION(left, right, pivot)\n    procedure moves items with smaller c[i] than c[pivot] to the left,\n    and greater to the right\n")),(0,i.kt)("p",null,"And the result is in right partition.\nAs it occurs this is just the special case for finding ",(0,i.kt)("b",null,"weighted k-th statistic"),". If you think of weighted k-th statistic\nproblem it reduces to the normal statistic with duplicates. For w","[i]"," we duplicate element c","[i]"," w","[i]"," times.\nThe algorithm is exactly the same either greedy of quick select. "),(0,i.kt)("h3",null,"Conclusion"),(0,i.kt)("p",null,"With the use of quick select we solved weighted median problem in linear time."),(0,i.kt)("p",null,"Thanks for reading."),(0,i.kt)("br",null),(0,i.kt)("br",null))}s.isMDXComponent=!0},9008:function(e,t,n){e.exports=n(5443)}},function(e){e.O(0,[774,888,179],(function(){return t=5855,e(e.s=t);var t}));var t=e.O();_N_E=t}]);