(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[714],{2382:function(e,t,s){(window.__NEXT_P=window.__NEXT_P||[]).push(["/posts/rust-by-example-1",function(){return s(8021)}])},8021:function(e,t,s){"use strict";s.r(t);var n=s(5893),i=s(9008);t.default=function(){return(0,n.jsx)("div",{children:(0,n.jsxs)("article",{className:"md:w-2/3 text-lg mr-auto ml-auto",children:[(0,n.jsxs)(i.default,{children:[(0,n.jsx)("script",{defer:!0,children:"hljs.highlightAll();"}),(0,n.jsx)("title",{children:"Rust by Example: ep. 1"}),(0,n.jsx)("meta",{name:"Description",content:"Short article showing how to solve sample LeetCode problem in Rust"})]}),(0,n.jsxs)("div",{className:"p-14",children:[(0,n.jsx)("h1",{className:"text-3xl font-bold text-center pb-14",children:"Rust by example: solving LeetCode problems 1"}),(0,n.jsxs)("p",{className:"mt-8",children:["Over a half year before I started learning Rust programming language. My interest grew again when I learned that ",(0,n.jsx)("a",{href:"https://github.com/tree-sitter/tree-sitter",children:"Tree Sitter"})," and recently ",(0,n.jsx)("a",{href:"https://github.blog/2021-12-09-introducing-stack-graphs/",children:"Stack Graphs"})," are implemented in it. Rust is best known for runtime performance, but it's memory management rules (borrowing and stuff) are hard to grasp for a newcomer."]}),(0,n.jsx)("p",{className:"mt-8",children:"I'm planning to write couple of posts, showing solutions to random LeetCode puzzles implemented in Rust. This one is first in series. Here I will be writing about borrowing rules and standard library."}),(0,n.jsx)("h2",{className:"text-2xl pt-8 py-8 font-bold",children:"Problem and solution"}),(0,n.jsxs)("p",{className:"mt-8",children:[(0,n.jsx)("a",{href:"https://leetcode.com/problems/longest-substring-without-repeating-characters/",children:"This"}),"  is a problem I chose. We have to find longest substring which doesn't have repeating characters in it. The solution is very simple, with hashset in place it is O(n)."]}),(0,n.jsxs)("p",{className:"mt-8",children:["So the idea is to scan string from left to right with ",(0,n.jsx)("b",{children:"i"})," index. While we are progressing to next characters we are adding them to hashset which holds unique elements. But if we find that new char is already in set we start removing characters from the back of our substring. The ",(0,n.jsx)("b",{children:"j"})," index is pointing to the first not removed yet char in our substring. So our substring is spanning from j to i and it's length is  ",(0,n.jsx)("b",{children:"i-j+1"})," with ",(0,n.jsx)("b",{children:"j stricly less than i"}),". We keep progressing j and removing chars from the set until set no longer contains char at i (or j hits i). This is how it would look like on example"]}),(0,n.jsx)("pre",{className:"mt-8",children:(0,n.jsx)("code",{children:"\n\nWe keep adding chars to the set...\n\n1. i=0, j=0, string=\"abcabc\", set={}\n\n2. i=1, j=0, string=\"abcabc\", set={'a'}\n\n3. i=2, j=0, string=\"abcabc\", set={'a', 'b'}\n\n4. i=3, j=0, string=\"abcabc\", set={'a', 'b', 'c'}\n\nAt string[3] we have 'a' again so set.contains('a') is true. \nWe keep removing chars from set and progressing j\n\n4.1. j=3, j=1, string=\"abcabc\", set={'b', 'c'}\nand finally add 'a'\n\n5. i=4, j=1, string=\"abcabc\", set={'a', 'b', 'c'}\n\n5.1 i=4, j=2, string=\"abcabc\", set={'a', 'c'}\n\n6. i=5, j=2, string=\"abcabc\", set={'a', 'b', 'c'}\n\n6.1 i=5, j=3, string=\"abcabc\", set={'a', 'b'}\n\n7. i=6, j=3, string=\"abcabc\", set={'a', 'b', 'c'}\n\n"})}),(0,n.jsx)("h2",{className:"text-2xl pt-14 py-8 font-bold",children:"Rust solution"}),(0,n.jsx)("p",{className:"mt-8",children:"And now lets see how it is done in Rust..."}),(0,n.jsx)("pre",{className:"p-5",children:(0,n.jsx)("code",{className:"language-rust",children:"\nuse std::collections::HashSet;\nuse std::cmp;\n\nimpl Solution {\n    pub fn length_of_longest_substring(s: String) -> i32 {\n        let mut letters = HashSet::new();\n        let chars:Vec<char> = s.chars().collect();\n        let mut j = 0;\n        let mut i = 0;\n        let mut maxLen = 0;\n        \n        while i < chars.len() {\n            let c = chars[i];\n            if !letters.contains(&c) {\n                letters.insert(c);\n            }\n            else {\n                while j < i && letters.contains(&c){\n                    let cj = chars[j];\n                    letters.remove(&cj);\n                    j += 1;\n                }\n                letters.insert(c);\n            }\n            maxLen = cmp::max(maxLen, i-j+1);\n            i += 1;\n        }\n        \n        return maxLen as i32;\n    }\n}\n"})}),(0,n.jsx)("p",{className:"mt-8",children:"There are couple of elements in play let's go through them one by one."}),(0,n.jsxs)("p",{className:"mt-8",children:[(0,n.jsx)("b",{children:"Mutablility"})," in Rust (as in other languages) there are two ways to allocate objects: on heap or stack. To allocate objects on stack we must know it's exact size. Further to allow modification we have to annotate variable with ",(0,n.jsx)("b",{children:"mut"})," if we want to reassigning it. That's why we have i and j mutable as well as maxLen and letters."]}),(0,n.jsxs)("p",{className:"mt-8",children:[(0,n.jsx)("b",{children:"Sizedness"})," check out this great ",(0,n.jsx)("a",{href:"https://github.com/pretzelhammer/rust-blog/blob/master/posts/sizedness-in-rust.md",children:"post"}),". Generally if types size can be measured at compile time it can be passed as value and reside on stack. All primitive types and structs and enums (recursively) are sized types."]}),(0,n.jsxs)("p",{className:"mt-8",children:[(0,n.jsx)("b",{children:"Copy"})," as you probably noticed we are assingning chars to c and cj. In fact we are creating copies because primitive types implement ",(0,n.jsx)("b",{children:"Copy trait"})," and are sized. What this means that on variable moving we are creating ",(0,n.jsx)("b",{children:"bitwise copy"})," of previouse element."]}),(0,n.jsxs)("p",{className:"mt-8",children:[(0,n.jsx)("b",{children:"Borrowing"})," most of the passing arguments to functions in Rust happens by borrowing. Borrowing is opposite to ",(0,n.jsx)("b",{children:"variable moving"})," because we don't take ownership of the variable inside function. However it has an limitation that we can't modify object with this reference (but we can copy it)."]}),(0,n.jsxs)("p",{className:"mt-8",children:[(0,n.jsx)("b",{children:"Casting"})," Rust doesn't support ",(0,n.jsx)("b",{children:"widening conversions"})," and we have to explicitly cast types. This is done with operator ",(0,n.jsx)("b",{children:"as"})]}),(0,n.jsx)("p",{className:"mt-8",children:"In this post we had an example of some Rust code for algorithmic challenge. It's not easy language but certainly more modern and you can get used to it's memory rules."})]})]})})}},9008:function(e,t,s){e.exports=s(5443)}},function(e){e.O(0,[774,888,179],(function(){return t=2382,e(e.s=t);var t}));var t=e.O();_N_E=t}]);