(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[27],{3905:function(e,t,n){"use strict";n.d(t,{kt:function(){return d}});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=r.createContext({}),u=function(e){var t=r.useContext(s),n=t;return e&&(n="function"===typeof e?e(t):a(a({},t),e)),n},c={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},p=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),d=u(n),h=o,f=d["".concat(s,".").concat(h)]||d[h]||c[h]||i;return n?r.createElement(f,a(a({ref:t},p),{},{components:n})):r.createElement(f,a({ref:t},p))}));function d(e,t){var n=arguments,o=t&&t.mdxType;if("string"===typeof e||o){var i=n.length,a=new Array(i);a[0]=p;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"===typeof e?e:o,a[1]=l;for(var u=2;u<i;u++)a[u]=n[u];return r.createElement.apply(null,a)}return r.createElement.apply(null,n)}p.displayName="MDXCreateElement"},9273:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/posts/newtype-pattern-application",function(){return n(8401)}])},8401:function(e,t,n){"use strict";n.r(t),n.d(t,{default:function(){return s}});n(7294);var r=n(3905),o=n(9008);function i(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var a={},l=function(e){var t=e.children;return(0,r.kt)("main",{className:"md:w-3/5 text-lg mr-auto ml-auto mt-20 pb-20 article"},t)};function s(e){var t=e.components,n=i(e,["components"]);return(0,r.kt)(l,Object.assign({},a,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)(o.default,{mdxType:"Head"},(0,r.kt)("script",{defer:!0},"hljs.highlightAll();"),(0,r.kt)("title",null,"One use of newtype pattern"),(0,r.kt)("meta",{name:"Description",content:"One use of newtype pattern"})),(0,r.kt)("h1",null,"One use of newtype pattern"),(0,r.kt)("p",null,"Recently I was working on tree algorithm that was rather complex. If this was not enough there were\ndifferent types of nodes, which complicated matters even more by ugly if-else blocks. I thought for\na while how can get rid of these and aha! ",(0,r.kt)("b",null,"Encapsulation"),". Instantly I thought of ",(0,r.kt)("b",null,"newtype"),"\npattern not widely know among programmers. What follows is how you can use it to reduce complexity\na bit."),(0,r.kt)("h3",null,"Prelude"),(0,r.kt)("p",null,"I already wrote about it couple of posts before but I will briefly refresh it. In Haskell you\nhave this construct by which you can encapsulate existing type in a ",(0,r.kt)("b",null,"new wrapper"),". Then\nthis becomes compeletely different type and somewhat you hide what you already wrote for\nold type behind this wrapper."),(0,r.kt)("p",null,"It becomes even more interesting when combined with OOP in Java. Let's say you have a tree with\ndifferent kinds of nodes."),(0,r.kt)("pre",{className:"mt-8"},(0,r.kt)("code",{className:"language-java"},"\n    public class Root {\n        public final List<InternalNode> children;\n\n        public Root(){\n            this.children = new ArrayList<>();\n        }\n\n        public void addChild(InternalNode node){\n            this.children.add(node);\n        }\n    }\n\n    public class InternalNode {\n        public final List<InternalNode> children;\n        public final List<Leaf> attributes;\n\n        public InternalNode() {\n            this.children = new ArrayList<>();\n            this.attributes = new ArrayList<>();\n        }\n\n        public void addChild(InternalNode node){\n            this.children.add(node);\n        }\n\n        public void addAttribute(Leaf att){\n            this.attributes.add(att);\n        }\n    }\n\n    public class Leaf {\n        public final Object value;\n\n        public Leaf(Object value) {\n            this.value = value;\n        }\n    }\n")),(0,r.kt)("p",null,"Imagine that old codes requirement was that each type of node has different kinds of logic attached or this logic is\nwritten with if's. You can't touch this structure, because either it's too much work or you don't control external jar."),(0,r.kt)("p",null,"Now imagine how processing this tree would look like..."),(0,r.kt)("pre",{className:"mt-8"},(0,r.kt)("code",{className:"language-java"},'\n    public static void walkTree(Root root, InternalNode internalNode, Leaf attribute){\n        if(root != null){\n            System.out.println("Visited Root");\n            root.children.forEach(in -> walkTree(null, in, null));\n        }\n        else if(internalNode != null){\n            System.out.println("Visited InternalNode");\n            internalNode.children.forEach(in -> walkTree(null, in, null));\n            internalNode.attributes.forEach(att -> walkTree(null, null, att));\n        }\n        else {\n            System.out.println("Visited attribute, value="+attribute.value);\n        }\n    }\n\n')),(0,r.kt)("p",null,"From the first sight you can't see what the code is doing, it's too blurred by the if's."),(0,r.kt)("h3",null,"Newtype"),(0,r.kt)("p",null,"But you can write your new logic in a different way. So to simplify this let's take those\nif's away and put them somewhere else. But where? How about creating one universal node\ntype that aggregates all three types of given nodes in itself. "),(0,r.kt)("pre",{className:"mt-8"},(0,r.kt)("code",{className:"language-java"},"\n    public class UniversalNode {\n        public enum NodeType {ROOT, INTERNAL, LEAF};\n\n        public final NodeType type;\n        private Root root;\n        private InternalNode internalNode;\n        private Leaf leaf;\n\n        public UniversalNode(Root root){\n            this.root = root;\n            this.type = NodeType.ROOT;\n        }\n\n        public UniversalNode(InternalNode internal){\n            this.internalNode = internal;\n            this.type = NodeType.INTERNAL;\n        }\n\n        public UniversalNode(Leaf leaf){\n            this.leaf = leaf;\n            this.type = NodeType.LEAF;\n        }\n    }\n\n")),(0,r.kt)("p",null,"This doesn't buy us anything yet. But having this structure we can treat all 3 different\ntypes of nodes as one. Just write one universal method doing something and hide the\nbranching in there. First let's implement logic of adding a child to UniversalNode."),(0,r.kt)("pre",{className:"mt-8"},(0,r.kt)("code",{className:"language-java"},'\n     public void addChild(UniversalNode other){\n            if(type == NodeType.ROOT){\n                if(other.type == NodeType.ROOT || other.type == NodeType.LEAF){\n                    throw new IllegalArgumentException("Doesn\'t conform to tree structure");\n                }\n                else {\n                    this.root.addChild(other.internalNode);\n                }\n            }\n            if(type == NodeType.INTERNAL){\n                if(other.type == NodeType.ROOT ){\n                    throw new IllegalArgumentException("Doesn\'t conform to tree structure");\n                }\n                else if (other.type == NodeType.LEAF){\n                    this.internalNode.addAttribute(other.leaf);\n                }\n                else {\n                    this.internalNode.addChild(other.internalNode);\n                }\n            }\n            if(type == NodeType.LEAF){\n                throw new IllegalArgumentException("Doesn\'t conform to tree structure");\n            }\n        }\n\n')),(0,r.kt)("p",null,"By doing this now we have a tree of only one type of Node. Let's go further and implement other methods:"),(0,r.kt)("pre",{className:"mt-8"},(0,r.kt)("code",{className:"language-java"},'\n       public List<UniversalNode> getChildren(){\n            if(type == NodeType.LEAF){\n                return List.of();\n            }\n            else if(type == NodeType.INTERNAL){\n                var lst = this.internalNode.children\n                        .stream().map(UniversalNode::new).toList();\n                lst.addAll(this.internalNode.attributes.stream().map(UniversalNode::new).toList());\n                return lst;\n            }\n            else {\n                return this.root.children.stream().map(UniversalNode::new).toList();\n            }\n        }\n        \n        public void printSelf(){\n            if(type == NodeType.LEAF){\n                System.out.println("Visited Leaf");\n            }\n            else if(type == NodeType.INTERNAL){\n                System.out.println("Visited InternalNode");\n            }\n            else {\n                System.out.println("Visited Root");\n            }\n        }\n\n')),(0,r.kt)("p",null,"Now take a look how you can rewrite tree walking to ",(0,r.kt)("b",null,"much")," simpler form."),(0,r.kt)("pre",{className:"mt-8"},(0,r.kt)("code",{className:"language-java"},"\n       public static void walkTree(UniversalNode un){\n        un.printSelf();\n        for(UniversalNode u : un.getChildren()){\n            walkTree(u);\n        }\n    }\n\n")),(0,r.kt)("h3",null,"Tree"),(0,r.kt)("figure",{className:"md:px-20 py-8"},(0,r.kt)("img",{src:"/newtype-1.png",width:"90%",height:"90%"}),(0,r.kt)("figcaption",{className:"font-bold text-center pt-5"},"Tree")),(0,r.kt)("p",null,"From this an interesting structure emerges. In terms of operations like ",(0,r.kt)("b",null,"addChild"),", ",(0,r.kt)("b",null,"setParent"),' etc\nwe are operating on an outer nodes. And tree is visible from the outside\nworld as built out of single type of node. But in those methods we are maintaining internal structure\nof "nested" nodes so we have 2 trees one inside another. When we are done we just get the internal\nnode of the root and get the old structure back. This is pretty elegant in my opinion.'),(0,r.kt)("h3",null,"Conclusion"),(0,r.kt)("p",null,"You maybe thinking meh what a big deal... This example is very simple, but sometimes you can\nhappen to be dealing with very algorithmetically intensive and exhausing work. You want to\nkeep this part as simple as possible to facilitate learning for newcomers for ex. And by\nmoving if's to universal type the rewrite of the method was possible to much cleaner form.\nI hope this makes sense, see you around."),(0,r.kt)("br",null),(0,r.kt)("br",null))}s.isMDXComponent=!0},9008:function(e,t,n){e.exports=n(5443)}},function(e){e.O(0,[774,888,179],(function(){return t=9273,e(e.s=t);var t}));var t=e.O();_N_E=t}]);