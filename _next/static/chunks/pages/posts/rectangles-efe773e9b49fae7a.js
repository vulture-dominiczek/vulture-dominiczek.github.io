(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[310],{3905:function(e,t,n){"use strict";n.d(t,{kt:function(){return f}});var r=n(7294);function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){l(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,l=function(e,t){if(null==e)return{};var n,r,l={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var s=r.createContext({}),c=function(e){var t=r.useContext(s),n=t;return e&&(n="function"===typeof e?e(t):o(o({},t),e)),n},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},p=r.forwardRef((function(e,t){var n=e.components,l=e.mdxType,a=e.originalType,s=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),f=c(n),h=l,g=f["".concat(s,".").concat(h)]||f[h]||u[h]||a;return n?r.createElement(g,o(o({ref:t},p),{},{components:n})):r.createElement(g,o({ref:t},p))}));function f(e,t){var n=arguments,l=t&&t.mdxType;if("string"===typeof e||l){var a=n.length,o=new Array(a);o[0]=p;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i.mdxType="string"===typeof e?e:l,o[1]=i;for(var c=2;c<a;c++)o[c]=n[c];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}p.displayName="MDXCreateElement"},586:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/posts/rectangles",function(){return n(8249)}])},8249:function(e,t,n){"use strict";n.r(t),n.d(t,{default:function(){return s}});n(7294);var r=n(3905),l=n(9008);function a(e,t){if(null==e)return{};var n,r,l=function(e,t){if(null==e)return{};var n,r,l={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var o={},i=function(e){var t=e.children;return(0,r.kt)("main",{className:"md:w-3/5 text-lg mr-auto ml-auto mt-20 pb-20 article"},t)};function s(e){var t=e.components,n=a(e,["components"]);return(0,r.kt)(i,Object.assign({},o,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)(l.default,{mdxType:"Head"},(0,r.kt)("script",{defer:!0},"hljs.highlightAll();"),(0,r.kt)("title",null,"Finding overlapping rectangles"),(0,r.kt)("meta",{name:"Description",content:"Finding overlapping rectangles"})),(0,r.kt)("h1",null,"Finding overlapping rectangles"),(0,r.kt)("p",null,"A problem from Cormen:"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},'VLSI databases commonly represent an integrated circuit as a list of rectangles.\nAssume that each rectangle is rectilinearly oriented (sides parallel to the xxx- and yyy-axes),\nso that we represent a rectangle by its minimum and maximum xxx and yyy-coordinates. Give an O(nlgn)-time algorithm to decide\nwhether or not a set of n rectangles so represented contains two rectangles that overlap. Your algorithm need not report all\nintersecting pairs, but it must report that an overlap exists if one rectangle entirely covers another, even if the boundary\nlines do not intersect. (Hint: Move a "sweep" line across the set of rectangles.)')),(0,r.kt)("p",null,"This is doable using interval tree. Let's see how to do it..."),(0,r.kt)("h3",null,"Intersection of rectangles"),(0,r.kt)("p",null,"When do the rectangles intersect?"),(0,r.kt)("figure",{className:"mt-10"},(0,r.kt)("img",{className:"mx-auto",src:"/rectangles.png",width:"60%",height:"60%"})),(0,r.kt)("p",null,"According to trichotomy of intervals, they can be in any of the three states:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"separate, first interval first, second interval second "),(0,r.kt)("li",{parentName:"ul"},"separate, second interval first, first interval second "),(0,r.kt)("li",{parentName:"ul"},"intersecting")),(0,r.kt)("p",null,"Then we would state that the intervals intersect when "),(0,r.kt)("b",null,"left1 <= right2 && right1 <= left2"),".",(0,r.kt)("p",null,"The same goes for the rectangles but we use a ",(0,r.kt)("b",null,"conjunction")," of the up-down and left-right bounds.\nFor rectangle intersection is when:"),(0,r.kt)("b",null,"left1 <= right2 && right1 <= left2"),(0,r.kt)("p",null,"and "),(0,r.kt)("b",null,"up1 <= down2 && up2 <= down1 "),(0,r.kt)("p",null,"conditions are met."),(0,r.kt)("h3",null,"Interval tree"),(0,r.kt)("p",null,"This is augumented balanced binary tree (red black tree for example) that allows to check intersection of given\ninterval in O(logN) time. The idea is to have intervals sorted by left end this being the key of the node while\nalso holding maximum x of right end that the subtree holds. Thanks to this while searching we can rule out\neither left or right subtree and this gives us the O(logN) time."),(0,r.kt)("h3",null,"Algorithm"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"We assume that we have collection of rectangles R, that each holds four vertices {r1, r2, r3, r4}."),(0,r.kt)("li",{parentName:"ul"},"We sort R by left","[R]","."),(0,r.kt)("li",{parentName:"ul"},"We build interval tree of R by rectangles intervals down","[R]","-up","[R]","."),(0,r.kt)("li",{parentName:"ul"},"We iterate sorted list of rectangles if the next rectangle intersects on X then we look up the associated\nvertical interval in interval tree. If there are more than 1 result, then we found intersecting rectangles."),(0,r.kt)("li",{parentName:"ul"},"Iteration - O(N) and search in interval tree O(logN).")),(0,r.kt)("h3",null,"Conclusion"),(0,r.kt)("p",null,"This concludes the post."),(0,r.kt)("p",null,"Thanks for reading."),(0,r.kt)("br",null),(0,r.kt)("br",null))}s.isMDXComponent=!0},9008:function(e,t,n){e.exports=n(5443)}},function(e){e.O(0,[774,888,179],(function(){return t=586,e(e.s=t);var t}));var t=e.O();_N_E=t}]);