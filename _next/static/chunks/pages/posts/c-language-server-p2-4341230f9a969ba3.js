(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[338],{1551:function(e,n,i){(window.__NEXT_P=window.__NEXT_P||[]).push(["/posts/c-language-server-p2",function(){return i(9036)}])},9036:function(e,n,i){"use strict";i.r(n);var s=i(5893),t=i(9008);n.default=function(){return(0,s.jsx)("div",{children:(0,s.jsxs)("article",{className:"md:w-3/5 text-lg mr-auto ml-auto",children:[(0,s.jsxs)(t.default,{children:[(0,s.jsx)("script",{defer:!0,children:"hljs.highlightAll();"}),(0,s.jsx)("title",{children:"C language server, part 2: linking multiple graphs"}),(0,s.jsx)("meta",{name:"Description",content:"C language server making of: linking symbols to definitions across files"})]}),(0,s.jsxs)("div",{className:"p-14",children:[(0,s.jsx)("h1",{className:"text-3xl font-bold text-center pb-14",children:"C language server, part 2: linking multiple graphs"}),(0,s.jsxs)("p",{className:"",children:["In previuos ",(0,s.jsx)("a",{href:"/posts/c-language-server-p1",children:"part"}),' I described implementation of parsing and definitions lookup inside single file. Tree sitter produced an Concrete Syntax Tree which was then reduced to "Stack Graph" tree of much smaller size. In this part I will be talking how I approached looking up definitions across files.']}),(0,s.jsxs)("p",{className:"mt-8",children:["First I created the ",(0,s.jsx)("b",{children:"StackGraphEngine"})," class to provide  methods to recursively walk directory and parse all the files ending in ",(0,s.jsx)("b",{children:".c"})," and ",(0,s.jsx)("b",{children:".h"}),". The parsed trees are kept in a hash map with absolute path as key and tree as value."]}),(0,s.jsxs)("p",{className:"mt-8",children:["Initial result is forest of dicrete trees with jumps contained within themselves. To allow for cross file lookup we need to ",(0,s.jsx)("b",{children:"analyze import statements"})," to bring in the definitions to the file in which they are present. I will be presenting ideas on toy example which I included below:"]}),(0,s.jsx)("pre",{className:"mt-8",children:(0,s.jsx)("code",{className:"language-c",children:'\n\n// -- corpus/sample2/def1.h\n\nstruct Employee {\n    string name;\n    string last_name;\n}\n   \n// -- corpus/sample2/def2.c\n\n#include <def2.h>\n\n\nvoid pretty_print(struct Organization org){\n    // code\n}\n\n\n// -- corpus/sample2/def2.h\n\n#include <def1.h>\n\nvoid pretty_print(struct Organization org);\n\nstruct Organization {\n    struct Employee emp;\n    string company_name;\n}\n\n// -- corpus/sample2/main.c\n\n#include <def2.h>\n\n\nint main(int argc, char* argv[]){\n    struct Organization org;\n\n\n    org.emp.name = "George";\n}\n\n'})}),(0,s.jsx)("h2",{className:"text-2xl pt-8 font-bold",children:"Imports and topological sorting"}),(0,s.jsxs)("p",{className:"",children:["The imports form a Directed Acyclic Graph (DAG). Each arrow brings in definitiion from pointed-to node. Note that this relations are transitive, what means that the definition at ",(0,s.jsx)("b",{children:"def1.h"})," should be visible in ",(0,s.jsx)("b",{children:"main.c"}),"."]}),(0,s.jsxs)("figure",{className:"mt-10",children:[(0,s.jsx)("img",{alt:"Node Parser",src:"/clang-2.png",width:"80%",height:"80%"}),(0,s.jsx)("figcaption",{className:"font-bold text-center",children:"Include graph"})]}),(0,s.jsx)("p",{className:"mt-8",children:"The idea of cross linking is very direct - let's always start from the node that has no imports and walk the way up. This is nothing more than putting files in topological order in which edge represents import statement. Just like on the above picture. There are two major algorithms of doing this but I chose simple one: Depth First Search."}),(0,s.jsxs)("p",{className:"mt-8",children:["We do crosslinking in single recursive DFS method. It accumulates transitive definitions in cache by file containing the imports. The definitions themselves are a hash map by name. After cache has been populated we iterate symbols in current translation unit (file) and we just look up definitions by symbol name in mentioned hash map. Then it's just a matter of setting symbol's ",(0,s.jsx)("b",{children:"jump_to"})," pointer to definition (which comes from another tree)."]}),(0,s.jsxs)("figure",{className:"mt-10",children:[(0,s.jsx)("img",{alt:"Node Parser",src:"/clang-3.png",width:"80%",height:"80%"}),(0,s.jsx)("figcaption",{className:"font-bold text-center",children:"Definitions propagation"})]}),(0,s.jsx)("h2",{className:"text-2xl pt-8 py-8 font-bold",children:"Implementation"}),(0,s.jsx)("pre",{className:"mt-8",children:(0,s.jsx)("code",{className:"language-c",children:"\n\nstruct StackGraphEngine\n{\n    unordered_map<Coordinate, shared_ptr<StackGraphNode>, CustomHash> node_table;\n    unordered_map<string, shared_ptr<StackGraphNode>> translation_units;\n    vector<CrossLink> cross_links;\n\n    void loadFile(string path);\n\n    void loadDirectoryRecursive(string path);\n\n    string resolveImport(string import);\n\n    shared_ptr<Point> resolve(Coordinate c);\n\n    vector<string> importsForTranslationUnit(string path);\n\n    vector<shared_ptr<StackGraphNode>> exportedDefinitionsForTranslationUnit(string path);\n\n    vector<shared_ptr<StackGraphNode>> symbolsForTranslationUnit(string path);\n\n    void _visitUnitsInTopologicalOrder(unordered_map<string, unordered_map<string, shared_ptr<StackGraphNode>>>& cache,\n                                       unordered_set<string>& visited,\n                                       unordered_map<string, string>& h_to_c,\n                                       string unit);\n\n    void crossLink();\n};\n\n\n"})}),(0,s.jsxs)("p",{className:"mt-8",children:["The workhorse is ",(0,s.jsx)("b",{children:"crossLink"})," method. It drives the linking phase and uses ",(0,s.jsx)("b",{children:"_visitUnitsInTopologicalOrder"})," internally. Cache contains all the definitions brought from imports for given translation unit. Like in every DFS we have to keep track which nodes we already visited and absolute paths are the nodes. ",(0,s.jsx)("b",{children:"h_to_c"}),' the "implied" import between headers and implementation files. Lastly the unit is currently visited node designator.']}),(0,s.jsx)("p",{className:"mt-8",children:"After the cache has been populated we are free to link symbols to definitions. After crossLink execution all symbols are bound to types and the algorithm with stack proceeds as normal. For debugging I wrote metadata class to track crosslinking dependencies, and printing them out looks like this:"}),(0,s.jsx)("pre",{className:"mt-8",children:(0,s.jsx)("code",{className:"language-shell",children:"\nCross Link {/home/dominik/Code/intellisense/c-language-server/corpus/sample2/def2.h#pretty_print ~~> /home/dominik/Code/intellisense/c-language-server/corpus/sample2/def2.c#pretty_print}\nCross Link {/home/dominik/Code/intellisense/c-language-server/corpus/sample2/def2.h#Organization ~~> /home/dominik/Code/intellisense/c-language-server/corpus/sample2/def2.h#Organization}\nCross Link {/home/dominik/Code/intellisense/c-language-server/corpus/sample2/def2.h#Employee ~~> /home/dominik/Code/intellisense/c-language-server/corpus/sample2/def1.h#Employee}\nCross Link {/home/dominik/Code/intellisense/c-language-server/corpus/sample2/def2.c#Organization ~~> /home/dominik/Code/intellisense/c-language-server/corpus/sample2/def2.h#Organization}\nCross Link {/home/dominik/Code/intellisense/c-language-server/corpus/sample2/main.c#Organization ~~> /home/dominik/Code/intellisense/c-language-server/corpus/sample2/def2.h#Organization}\n"})}),(0,s.jsx)("h2",{className:"text-2xl pt-14 py-8 font-bold",children:"Conclusion"}),(0,s.jsxs)("p",{className:"mt-8",children:["I'm halfway done with the implementation, in next episode I will ponder how I can implement (subset of) ",(0,s.jsx)("a",{href:"https://microsoft.github.io/language-server-protocol/",children:"LSP"}),". Thanks for reading. Don't forget to check out the ",(0,s.jsx)("a",{href:"https://github.com/dgawlik/c-language-server",children:"code"}),"."]})]})]})})}},9008:function(e,n,i){e.exports=i(5443)}},function(e){e.O(0,[774,888,179],(function(){return n=1551,e(e.s=n);var n}));var n=e.O();_N_E=n}]);