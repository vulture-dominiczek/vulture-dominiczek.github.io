(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[725],{3905:function(t,e,n){"use strict";n.d(e,{kt:function(){return c}});var a=n(7294);function r(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function s(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,a)}return n}function i(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?s(Object(n),!0).forEach((function(e){r(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function o(t,e){if(null==t)return{};var n,a,r=function(t,e){if(null==t)return{};var n,a,r={},s=Object.keys(t);for(a=0;a<s.length;a++)n=s[a],e.indexOf(n)>=0||(r[n]=t[n]);return r}(t,e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(t);for(a=0;a<s.length;a++)n=s[a],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(r[n]=t[n])}return r}var l=a.createContext({}),p=function(t){var e=a.useContext(l),n=e;return t&&(n="function"===typeof t?t(e):i(i({},e),t)),n},d={inlineCode:"code",wrapper:function(t){var e=t.children;return a.createElement(a.Fragment,{},e)}},u=a.forwardRef((function(t,e){var n=t.components,r=t.mdxType,s=t.originalType,l=t.parentName,u=o(t,["components","mdxType","originalType","parentName"]),c=p(n),m=r,h=c["".concat(l,".").concat(m)]||c[m]||d[m]||s;return n?a.createElement(h,i(i({ref:e},u),{},{components:n})):a.createElement(h,i({ref:e},u))}));function c(t,e){var n=arguments,r=e&&e.mdxType;if("string"===typeof t||r){var s=n.length,i=new Array(s);i[0]=u;var o={};for(var l in e)hasOwnProperty.call(e,l)&&(o[l]=e[l]);o.originalType=t,o.mdxType="string"===typeof t?t:r,i[1]=o;for(var p=2;p<s;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},8619:function(t,e,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/posts/rust-by-example-2",function(){return n(4191)}])},4191:function(t,e,n){"use strict";n.r(e),n.d(e,{default:function(){return l}});n(7294);var a=n(3905),r=n(9008);function s(t,e){if(null==t)return{};var n,a,r=function(t,e){if(null==t)return{};var n,a,r={},s=Object.keys(t);for(a=0;a<s.length;a++)n=s[a],e.indexOf(n)>=0||(r[n]=t[n]);return r}(t,e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(t);for(a=0;a<s.length;a++)n=s[a],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(r[n]=t[n])}return r}var i={},o=function(t){var e=t.children;return(0,a.kt)("main",{className:"md:w-3/5 text-lg mx-auto mt-20 pb-20 article"},e)};function l(t){var e=t.components,n=s(t,["components"]);return(0,a.kt)(o,Object.assign({},i,n,{components:e,mdxType:"MDXLayout"}),(0,a.kt)(r.default,{mdxType:"Head"},(0,a.kt)("script",{defer:!0},"hljs.highlightAll();"),(0,a.kt)("title",null,"Rust by Example: ep. 2"),(0,a.kt)("meta",{name:"Description",content:"Short article showing how to write simple sniffer in Rust"})),(0,a.kt)("h1",null,"Rust by example: simple sniffer"),(0,a.kt)("p",null," Some time ago I was learning about linux'es network stack and started by looking at the traffic in Wireshark.\nMeanwhile I was learning Rust so\ndecided to write myself a simple ",(0,a.kt)("a",{href:"https://en.wikipedia.org/wiki/Pcap"},"PCAP"),"-using tool. I found it\neasier than I thought and result is more like a script than package. Here I will be sharing my experiences\nand what I learned."),(0,a.kt)("h3",null,"PCAP"),(0,a.kt)("b",null,"PCAP")," is an API for programmers to write network monitoring tools. It originated in Berkeley Laboratory, and itself was attempt to unificate code of various system distributions. The attempt succeeded and currently available on MacOS, Windows and Linux. The most widely known tool using it is ",(0,a.kt)("b",null,"tcpdump")," which is further used by graphical interfaces like Wireshark.",(0,a.kt)("p",null,"What you get from this C library is raw layer 2 data. Most widely it is ",(0,a.kt)("b",null,"Ethernet v2")," but\ncan be any Link Layer protocol and there are many of them. PCAP talks directly to the network card and mirrors\nthe traffic independently of OS network stack. You can even inject some frame to the stack. However, this is\na raw data which needs to be parsed, and this what we will be doing."),(0,a.kt)("h3",null,"Networking theory"),(0,a.kt)("p",null,"  Quick theory recap: networking traffic is organized into layers. Lowest layer is Phisical Layer and this is 1's and 0's\nflowing throught the wire or over the radio antenna. Next there is Link Layer and it is a language of various networking\ndevices like bridges, switches and network cards. Then there is logical IP that with the use of ",(0,a.kt)("b",null,"routers")," knows\nwhere to transport packet anywhere in the world. But IP itself doesn't handle fragmentation so nexl level layers ",(0,a.kt)("b",null,"TCP or UDP")," allow to send much larger segments."),(0,a.kt)("figure",{className:"md:px-20 py-8"},(0,a.kt)("img",{alt:"OSI Layersr",src:"/rust-ex-2.jpeg",width:"90%",height:"90%"}),(0,a.kt)("figcaption",{className:"font-bold text-center pt-5"},"OSI Layers")),(0,a.kt)("p",null,"  Each time the frame is sent it goes from the upper layer to the lower layer. The binary data is ",(0,a.kt)("b",null,"encapsulated")," or\nwrapped in lower layer's frame. When it is beeing received the reverse process happens - it is ",(0,a.kt)("b",null,"decapsulated"),"."),(0,a.kt)("h3",null,"Rust interlude"),(0,a.kt)("p",null," Rust is multi-paradigm language and there are many ways to describe same thing. Robert C. Martin in his ",(0,a.kt)("a",{href:"https://blog.cleancoder.com/uncle-bob/2014/11/24/FPvsOO.html"},"Clean Code"),"\nseries observed that ",(0,a.kt)("b",null,"Object Oriented")," and ",(0,a.kt)("b",null,"Functional Programming")," are complementary. In OO you have ",(0,a.kt)("b",null,"dynamic dispatch")," and\nyou hide differnt object types behind common interface. By doing so it is easy to extend ",(0,a.kt)("b",null,"structure")," but hard to extend behaviuour.\nOn FP side of things opposite is true. You just have pure functions operating on structures. Each time you want to add behaviour you just write another\nfunction but when you change structure you have to reimplement all functions."),(0,a.kt)("p",null,'It appears to me that Rust leans more towards Functinal Programming. True there are dynamic trait objects but their use is cumbersome\nand "all around". The rich enums and pattern matching seems to be cleaner way to implement stuff and writing in this style\nwas pure pleasure for me. However I\'m still learning the language so this statement may be premature.'),(0,a.kt)("p",null,"While writing my little script I had to look up the frame formats in various sites and RFC's and I'm putting this\ndata here for your convenience. For clarity I ommitted some values but you can find them in code."),(0,a.kt)("h3",null,"Reference"),(0,a.kt)("p",null,"Next I had to gather offsets from variuos sites and RFCs. Below is the data used. The implementation correctness hangs on\nassumption that the underlying frame is Ethernet 2. However it could be also 802.11 which is rarer, but in such case\nthe code won't work."),(0,a.kt)("p",null,"Implementation returns Attributes as strings, in hex format for Ethernet and Ipv6, dot format in Ipv4, and numbers for\nudp and tcp ports."),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",Object.assign({parentName:"tr"},{align:null}),(0,a.kt)("strong",{parentName:"th"},"Protocol")),(0,a.kt)("th",Object.assign({parentName:"tr"},{align:null}),(0,a.kt)("strong",{parentName:"th"},"Attribute")),(0,a.kt)("th",Object.assign({parentName:"tr"},{align:null}),(0,a.kt)("strong",{parentName:"th"},"Location (bytes)")))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",Object.assign({parentName:"tr"},{align:null}),"Ethernet2"),(0,a.kt)("td",Object.assign({parentName:"tr"},{align:null}),"Source Address"),(0,a.kt)("td",Object.assign({parentName:"tr"},{align:null}),(0,a.kt)("strong",{parentName:"td"},"0..5"))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",Object.assign({parentName:"tr"},{align:null}),"Ethernet2"),(0,a.kt)("td",Object.assign({parentName:"tr"},{align:null}),"Destination Address"),(0,a.kt)("td",Object.assign({parentName:"tr"},{align:null}),(0,a.kt)("strong",{parentName:"td"},"6..11"))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",Object.assign({parentName:"tr"},{align:null}),"Ethernet2"),(0,a.kt)("td",Object.assign({parentName:"tr"},{align:null}),"Payload"),(0,a.kt)("td",Object.assign({parentName:"tr"},{align:null}),(0,a.kt)("strong",{parentName:"td"},"14..len-4"))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",Object.assign({parentName:"tr"},{align:null}),"Ip4"),(0,a.kt)("td",Object.assign({parentName:"tr"},{align:null}),"Source Address"),(0,a.kt)("td",Object.assign({parentName:"tr"},{align:null}),(0,a.kt)("strong",{parentName:"td"},"12..15"))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",Object.assign({parentName:"tr"},{align:null}),"Ip4"),(0,a.kt)("td",Object.assign({parentName:"tr"},{align:null}),"Destination Address"),(0,a.kt)("td",Object.assign({parentName:"tr"},{align:null}),(0,a.kt)("strong",{parentName:"td"},"16..19"))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",Object.assign({parentName:"tr"},{align:null}),"Ip4"),(0,a.kt)("td",Object.assign({parentName:"tr"},{align:null}),"Payload"),(0,a.kt)("td",Object.assign({parentName:"tr"},{align:null}),(0,a.kt)("strong",{parentName:"td"},"20.."))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",Object.assign({parentName:"tr"},{align:null}),"Ip6"),(0,a.kt)("td",Object.assign({parentName:"tr"},{align:null}),"Source Address"),(0,a.kt)("td",Object.assign({parentName:"tr"},{align:null}),(0,a.kt)("strong",{parentName:"td"},"8..23"))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",Object.assign({parentName:"tr"},{align:null}),"Ip6"),(0,a.kt)("td",Object.assign({parentName:"tr"},{align:null}),"Destination Address"),(0,a.kt)("td",Object.assign({parentName:"tr"},{align:null}),(0,a.kt)("strong",{parentName:"td"},"24..40"))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",Object.assign({parentName:"tr"},{align:null}),"Ip6"),(0,a.kt)("td",Object.assign({parentName:"tr"},{align:null}),"Payload"),(0,a.kt)("td",Object.assign({parentName:"tr"},{align:null}),(0,a.kt)("strong",{parentName:"td"},"40.."))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",Object.assign({parentName:"tr"},{align:null}),"Udp"),(0,a.kt)("td",Object.assign({parentName:"tr"},{align:null}),"Source Address"),(0,a.kt)("td",Object.assign({parentName:"tr"},{align:null}),(0,a.kt)("strong",{parentName:"td"},"0..1"))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",Object.assign({parentName:"tr"},{align:null}),"Udp"),(0,a.kt)("td",Object.assign({parentName:"tr"},{align:null}),"Destination Address"),(0,a.kt)("td",Object.assign({parentName:"tr"},{align:null}),(0,a.kt)("strong",{parentName:"td"},"2..3"))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",Object.assign({parentName:"tr"},{align:null}),"Udp"),(0,a.kt)("td",Object.assign({parentName:"tr"},{align:null}),"Payload"),(0,a.kt)("td",Object.assign({parentName:"tr"},{align:null}),(0,a.kt)("strong",{parentName:"td"},"8.."))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",Object.assign({parentName:"tr"},{align:null}),"Tcp"),(0,a.kt)("td",Object.assign({parentName:"tr"},{align:null}),"Source Address"),(0,a.kt)("td",Object.assign({parentName:"tr"},{align:null}),(0,a.kt)("strong",{parentName:"td"},"0..1"))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",Object.assign({parentName:"tr"},{align:null}),"Tcp"),(0,a.kt)("td",Object.assign({parentName:"tr"},{align:null}),"Destination Address"),(0,a.kt)("td",Object.assign({parentName:"tr"},{align:null}),(0,a.kt)("strong",{parentName:"td"},"2..3"))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",Object.assign({parentName:"tr"},{align:null}),"Tcp"),(0,a.kt)("td",Object.assign({parentName:"tr"},{align:null}),"Payload"),(0,a.kt)("td",Object.assign({parentName:"tr"},{align:null}),(0,a.kt)("strong",{parentName:"td"},"hdr_len.."))))),(0,a.kt)("h3",null,"Implementing"),(0,a.kt)("p",null," I started by defining structures. Thanks to using enum we can use rich pattern matching which is easy to write.\nWe wrap raw data in enum value giving it meaning. This is a ",(0,a.kt)("b",null,"newtype")," pattern which is called so by Rust\ncommunity after some construct in Haskell. In short you ",(0,a.kt)("b",null,"wrap existing type")," in enum or struct. Then you hide\nolders type implementation details behind your new type. Because you have new type you can implement traits for it\nor just write plain functions."),(0,a.kt)("pre",{className:"p-5"},(0,a.kt)("code",{className:"language-rust"},"\nenum Record<'a> {\n    Ethernet2Frame(&'a [u8]),\n    Ip4Packet(&'a [u8]),\n    Ip6Packet(&'a [u8]),\n    TcpSegment(&'a [u8]),\n    UdpPacket(&'a [u8]),\n}\n")),(0,a.kt)("p",null,"Next for source address, destination address, payload I wrote parsing in separate methods.\nNice thing in Rust is functional api for operating on collections. Here on ",(0,a.kt)("b",null,"print_dot")," example\nI get the iterator, map values to strings, join them together with dot. The result is option, but\nI know it always is ",(0,a.kt)("b",null,"Some")," so I can safely unwrap."),(0,a.kt)("p",null,"Then in ",(0,a.kt)("b",null,"source_address")," I used pattern matching to tie parsing with frame type. In Rust you\ncan destructure the type to get it's internals so I use that to get ",(0,a.kt)("b",null,"b: &","[u8]")," inside enums variant."),(0,a.kt)("pre",{className:"p-5"},(0,a.kt)("code",{className:"language-rust"},'\nfn print_dot(data: &[u8]) -> String {\n    data.to_vec()\n        .iter()\n        .map(|x| format!("{}", x))\n        .reduce(|a, b| format!("{}.{}", a, b))\n        .unwrap()\n}\n\nfn print_hex(data: &[u8]) -> String {\n    data.to_vec()\n        .iter()\n        .map(|x| hex::encode([*x]))\n        .reduce(|a, b| format!("{}:{}", a, b))\n        .unwrap()\n}\n\nfn source_address(rec: &Record) -> String {\n    match rec {\n        Record::Ethernet2Frame(b) => print_hex(&b[..6]),\n        Record::Ip4Packet(b) => print_dot(&b[12..16]),\n        Record::Ip6Packet(b) => print_hex(&b[8..24]),\n        Record::TcpSegment(b) => {\n            let mut addr = (b[0] as u16) << 8;\n            addr += b[1] as u16;\n            format!("{}", addr)\n        }\n        Record::UdpPacket(b) => {\n            let mut addr = (b[0] as u16) << 8;\n            addr += b[1] as u16;\n            format!("{}", addr)\n        }\n    }\n}\n')),(0,a.kt)("p",null," The most interesting part is decapsulation. What is interesting here that we jump from one\nenum's variant to another or return ",(0,a.kt)("b",null,"None")," if this is some case we didn't consider yet.\nAnd so we can decapsulate Etherenet2 to Ipv4 and Ipv6. Then we can decapsulate either Ipv4 or Ipv4\nto Tcp or Udp.  Note that the capturing whole case is done with ",(0,a.kt)("b",null,"@")," in Rust."),(0,a.kt)("pre",{className:"p-5"},(0,a.kt)("code",{className:"language-rust"},'\nfn decapsulate<\'a>(rec: &\'a Record) -> Option<Record<\'a>> {\n    match rec {\n        eth @ Record::Ethernet2Frame(b)=> {\n            let ethertype = &b[12..14];\n\n            if hex::encode(ethertype) == "0800" {\n                Some(Record::Ip4Packet(payload(eth)))\n            }\n            else if hex::encode(ethertype) == "86dd" {\n                Some(Record::Ip6Packet(payload(eth)))\n            }\n            else {\n                None\n            }\n        },\n        ip4 @ Record::Ip4Packet(b) => {\n            if b[9] == 17 {\n                Some(Record::UdpPacket(payload(ip4)))\n            }\n            else if b[9] == 6 {\n                Some(Record::TcpSegment(payload(ip4)))\n            }\n            else {\n                None\n            }\n        },\n        ip6 @ Record::Ip6Packet(b) => {\n            if b[6] == 17 {\n                Some(Record::UdpPacket(payload(ip6)))\n            }\n            else if b[6] == 6 {\n                Some(Record::TcpSegment(payload(ip6)))\n            }\n            else {\n                None\n            }\n        },\n        _ => None\n    }\n}\n')),(0,a.kt)("p",null," The last part is main method, I quickly implemented\nargument parsing with ",(0,a.kt)("a",{href:"https://github.com/clap-rs/clap"},"Clap")," and filtering of the payloads is done by JSON path\nwhich is done by ",(0,a.kt)("a",{href:"https://crates.io/crates/jsonpath-rust"},"jsonpath-rust")," and ",(0,a.kt)("a",{href:"https://docs.serde.rs/serde_json/"},"serde_json"),".\nThe original concept was that if the jsonpath query matches then let's print the result in the commandline."),(0,a.kt)("pre",{className:"p-5"},(0,a.kt)("code",{className:"language-rust"},'\nfn main() {\n    let device = Device::lookup().unwrap();\n\n    let mut pcap = Capture::from_device(device)\n        .unwrap()\n        .promisc(true)\n        .immediate_mode(true)\n        .snaplen(5000)\n        .open()\n        .unwrap();\n\n    let args = Args::parse();\n\n\n    loop {\n        if let Ok(packet) = pcap.next() {\n            let eth = Record::Ethernet2Frame(packet.data);\n\n            let mut root = serde_json::Map::new();\n\n            let ethernet = serde_json::json!({\n                "source": source_address(&eth),\n                "destination": destination_address(&eth)\n            });\n\n            root.insert(name(&eth), ethernet);\n\n           \n            if let Some(ip) = decapsulate(&eth) {\n                let ip_packet = serde_json::json!({\n                    "source": source_address(&ip),\n                    "destination": destination_address(&ip),\n                });\n\n                root.insert(name(&ip), ip_packet);\n\n                if let Some(l4) = decapsulate(&ip){\n                    let l4_packet = serde_json::json!({\n                        "source": source_address(&l4),\n                        "destination": destination_address(&l4),\n                    });\n\n                    root.insert(name(&l4), l4_packet);\n                }\n            }\n\n\n            let mut s = String::from("");\n            for b in packet.data {\n                let c = char::from(b.clone());\n                if c.is_alphanumeric() {\n                    s.push(c);\n                } else {\n                    s.push_str(".");\n                }\n            }\n            root.insert(String::from("data"), serde_json::Value::String(s));\n\n            let obj = serde_json::Value::Object(root);\n\n            if let Ok(res) =  &obj.clone().path("$..book[?(@.author size 10)].title") {\n                println!(\n                    "{}",\n                    serde_json::to_string_pretty(&obj).unwrap()\n                )\n            }\n           \n        }\n    }\n}\n')),(0,a.kt)("h3",null,"The code"),(0,a.kt)("p",null," You can get the whole code in ",(0,a.kt)("a",{href:"https://gist.github.com/dgawlik/bbc70f7b10900440bf05fb89830197dd"},"here"),". I have put it in Gist with dependencies in toml.\nFeel free to extend it and try it out on your machine. Thanks for reading."),(0,a.kt)("br",null),(0,a.kt)("br",null))}l.isMDXComponent=!0},9008:function(t,e,n){t.exports=n(5443)}},function(t){t.O(0,[774,888,179],(function(){return e=8619,t(t.s=e);var e}));var e=t.O();_N_E=e}]);