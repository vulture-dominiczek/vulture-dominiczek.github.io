(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[459],{3905:function(e,n,t){"use strict";t.d(n,{kt:function(){return h}});var i=t(7294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,i,o=function(e,n){if(null==e)return{};var t,i,o={},a=Object.keys(e);for(i=0;i<a.length;i++)t=a[i],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)t=a[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var l=i.createContext({}),d=function(e){var n=i.useContext(l),t=n;return e&&(t="function"===typeof e?e(n):r(r({},n),e)),t},c={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},u=i.forwardRef((function(e,n){var t=e.components,o=e.mdxType,a=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),h=d(t),p=o,m=h["".concat(l,".").concat(p)]||h[p]||c[p]||a;return t?i.createElement(m,r(r({ref:n},u),{},{components:t})):i.createElement(m,r({ref:n},u))}));function h(e,n){var t=arguments,o=n&&n.mdxType;if("string"===typeof e||o){var a=t.length,r=new Array(a);r[0]=u;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s.mdxType="string"===typeof e?e:o,r[1]=s;for(var d=2;d<a;d++)r[d]=t[d];return i.createElement.apply(null,r)}return i.createElement.apply(null,t)}u.displayName="MDXCreateElement"},5118:function(e,n,t){(window.__NEXT_P=window.__NEXT_P||[]).push(["/posts/c-language-server-p4",function(){return t(8795)}])},8795:function(e,n,t){"use strict";t.r(n),t.d(n,{default:function(){return l}});t(7294);var i=t(3905),o=t(9008);function a(e,n){if(null==e)return{};var t,i,o=function(e,n){if(null==e)return{};var t,i,o={},a=Object.keys(e);for(i=0;i<a.length;i++)t=a[i],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)t=a[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var r={},s=function(e){var n=e.children;return(0,i.kt)("main",{className:"md:w-3/5 text-lg mr-auto ml-auto mt-20 pb-20 article"},n)};function l(e){var n=e.components,t=a(e,["components"]);return(0,i.kt)(s,Object.assign({},r,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)(o.default,{mdxType:"Head"},(0,i.kt)("script",{defer:!0},"hljs.highlightAll();"),(0,i.kt)("title",null,"C language server: VSCode Plugin"),(0,i.kt)("meta",{name:"Description",content:"Implementation of VSCode plugin communicating with C language server"})),(0,i.kt)("h1",null,"C language server: VSCode Plugin"),(0,i.kt)("p",null,"This is the last post I'm planning to write in the series. The server has been implemented and it is working to reasonable\nextent. Now what is left to do is Visual Studio Code plugin and communication between the two. The whole code is available ",(0,i.kt)("a",{href:"https://github.com/dgawlik/c-language-server"},"here")," if you want to know the nitty-gritty details."),(0,i.kt)("p",null,"First some picture:"),(0,i.kt)("figure",{className:"mt-10"},(0,i.kt)("img",{alt:"Node Parser",src:"/clang-4.png",width:"60%",height:"60%"}),(0,i.kt)("figcaption",{className:"font-bold text-center"},"Sequence diagram")),(0,i.kt)("p",null,"This is the outline of the system working.\nI was wondering what is simple and efficient way to implement communication. I picked grpc first enticed by performance. Since\nthe payloads would be binary the latency should be minimal.\nBut then I realized my payloads are rather small and it would be overkill for this purpose and ",(0,i.kt)("b",null,"setup is rather hard in C++"),".\nBesides it don't like the idea of regenerating classes each time I change schema. "),(0,i.kt)("b",null,"JSON-RPC")," is the way VSCode guys chose to standarize on. But then I would be tided to the ",(0,i.kt)("a",{href:"https://microsoft.github.io/language-server-protocol/specification"},"LSP/LSI spec")," and would need to implement all the stuff I don't need and don't have time to do. I was left with implementing communication all by myself.",(0,i.kt)("p",null,"But is there a lot of work to be done? Not really... I went with very simple schema: plugin spawns a server process and acquires\nit's standard input and output. Then the communication is simply by exchanging ",(0,i.kt)("b",null,"lines")," between server and client.\nAnd each line is stringified JSON object. Request and reponse have ",(0,i.kt)("b",null,"command")," field indicating\nwhich action should be taken by server.\nServer responds with payload correlated with command name again. The solution is very minimal and easy and I like it."),(0,i.kt)("h3",null,"The plugin"),(0,i.kt)("a",{href:"https://code.visualstudio.com/api/extension-guides/notebook"},"The API")," is organized as follows. First there are 2 categories of plugins: normal and languages support. To be honest I was expecting something different for language integration. It is very tightly built in the editor and you are dependant on the specs mentioned.",(0,i.kt)("p",null,"Other plugins have more freedom but not everything can be done easily. In theory any action could be done by ",(0,i.kt)("b",null,"commands")," but sometimes\nyou also have to read editors contents. Then there are objects like ",(0,i.kt)("b",null,"window.activeTextEditor")," from which you can fetch the file contents."),(0,i.kt)("p",null,"So I abandoned the idea of implementing language integration the official way. The way I did it instead is registering 3 commands: index,\nresolve definition and find usages and binding them to key shortcuts. Indexing and finding definitions went smooth because they didn't need custom gui do display results.\nFinding usages required displaying page with list of files and line locations."),(0,i.kt)("p",null,"I will only paste a small part how implementation of the plugin looks like."),(0,i.kt)("pre",{className:"mt-8"},(0,i.kt)("code",{className:"language-js"},"\nelse if (data.command == 'resolve') {\n    if (data.status == \"not_found\") {\n        vscode.window.showInformationMessage('Not found!');\n    }\n    else {\n        await vscode.commands.executeCommand(\"vscode.open\", vscode.Uri.parse(data.coordinate.path));\n        let editor = vscode.window.activeTextEditor;\n        let range = editor.document.lineAt(data.coordinate.line).range;\n        editor.selection = new vscode.Selection(range.start, range.end);\n        editor.revealRange(range);\n\n    }\n}\n")),(0,i.kt)("p",null,"Here you can see how you can navigate to definition on reference found. First you open the absolute path, luckily if file is\ninside opened directory the file merges into already opened. Then there is no simple way to move cursor. Instead you can\nmock the behaviour by selecting a given line with ",(0,i.kt)("b",null,"editor.revealRange(range)")),(0,i.kt)("p",null,"This was for finding definition. Other way around for displaying all usages, the only way I found that didn't require\nlots of work was to display html page with links by ",(0,i.kt)("b",null,"vscode.window.createWebviewPanel"),". So basically\nI used string interpolation to craft html, put it inside panel and display it to the side.\nBut then it would be nice for the links  to be clickable, which is not supported currently.\nWhile searching the internet I found the github issue however in which developers of VSCode showed a hack how to do this.\nVSCode provides in browser api to post messages to the node engine.\nThen, server side you can parse it and open the link from there. "),(0,i.kt)("p",null,"Here is the code:"),(0,i.kt)("pre",{className:"mt-8"},(0,i.kt)("code",{className:"language-js"},"\nconst vscode = acquireVsCodeApi();\n\nfor (const link of document.querySelectorAll('a[href^=\"c-lang-ref:\"]')) {\n    link.addEventListener('click', () => {\n        vscode.postMessage({\n            command: \"open\",\n            link: link.getAttribute('href').replace('c-lang-ref', 'file'),\n        });\n    });\n}\n")),(0,i.kt)("p",null,"You put this code in script tag inside panels html.\nThen you tweak panels options to enable script execution. And then you parse message from inside the plugin and open\nthe document linked. "),(0,i.kt)("h3",null,"C++ part"),(0,i.kt)("p",null,"Now very shortly about the sending the messages. I found very ",(0,i.kt)("a",{href:"https://github.com/nlohmann/json"},"nice")," json implementation for\nC++. It acts like a hash map that makes it really easy to work with. It is used like so (for reading):"),(0,i.kt)("pre",{className:"mt-8"},(0,i.kt)("code",{className:"language-cpp"},'\n void loop()\n    {\n        while (true)\n        {\n            std::string line;\n\n            std::getline(std::cin, line);\n\n            json parsed = json::parse(line);\n\n            switch (hash(parsed["command"].get<string>().c_str()))\n            {\n            case hash("stop"):\n                exit(0);\n            case hash("index"):\n                do_index(parsed["payload"]);\n                break;\n            case hash("resolve"):\n                resolve(parsed["payload"]);\n                break;\n            case hash("find_usages"):\n                find_usages(parsed["payload"]);\n                break;\n            case hash("debug_print_tree"):\n                debug_print_tree(parsed["payload"]);\n                break;\n            default:\n                std::cout << line << std::endl;\n            }\n        }\n    }\n')),(0,i.kt)("p",null,"The server never ends. It's simply killed on close by the plugin. In each iteration it waits for a line on stdin and parses the\nJSON. C++ still doesn't have switch on strings so you have to do a trick and hash it to integer. Anyways, next the field \"command\"\ndispatches the action to be taken."),(0,i.kt)("p",null,"I would be skipping the rest for brevity if you are interested see the repository linked."),(0,i.kt)("h3",null,"Result"),(0,i.kt)("p",null,"I think I finished this project for now. I am rather happy with the results. It is relatively fast as it indexes kernel repo in 4 minutes on my computer.\nAnd basic navigation seems to be working. I will take it for a spin when I learn about linux and maybe extend it more or fix some bugs, but for now I will find something else to write about.\nI hope you liked this series, see you next time!"),(0,i.kt)("br",null),(0,i.kt)("br",null))}l.isMDXComponent=!0},9008:function(e,n,t){e.exports=t(5443)}},function(e){e.O(0,[774,888,179],(function(){return n=5118,e(e.s=n);var n}));var n=e.O();_N_E=n}]);