(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[531],{8664:function(e,n,i){(window.__NEXT_P=window.__NEXT_P||[]).push(["/posts/c-language-server-p1",function(){return i(2872)}])},2872:function(e,n,i){"use strict";i.r(n);var t=i(5893),r=i(9008);n.default=function(){return(0,t.jsx)("div",{children:(0,t.jsxs)("article",{className:"md:w-3/5 text-lg mr-auto ml-auto",children:[(0,t.jsxs)(r.default,{children:[(0,t.jsx)("script",{defer:!0,children:"hljs.highlightAll();"}),(0,t.jsx)("title",{children:"C language server: single file navigation"}),(0,t.jsx)("meta",{name:"Description",content:"Stack Graphs' inspired C++ implementation of C language server: parsing of single file"})]}),(0,t.jsxs)("div",{className:"p-14",children:[(0,t.jsx)("h1",{className:"text-3xl font-bold text-center pb-8",children:"C language server: single file navigation"}),(0,t.jsxs)("p",{className:"",children:["Recently I was catching up with news in software and I came by ",(0,t.jsx)("a",{href:"https://www.youtube.com/watch?v=l2R1PTGcwrE",children:"this"})," talk from github blog. It presents the method to implement code navigation for any language using their (Github's) tool stack graph. Basically you create a graph and their tool handles navigation on it's vertices to jump from reference to definition."]}),(0,t.jsx)("p",{className:"mt-8",children:"I wanted to try out the ideas presented which seemed cool. One use case I would particularly welcome is searching all references of definition in vscode and it's currently lacking  (it just scans all the files). I decided I will translate ideas from talk to code and implement it."}),(0,t.jsx)("p",{className:"mt-8",children:"There were couple of things left out and was not comfortable enough in Rust so I started implementing kind of similar solution in C++. In this article I present how I adopted linked talk to finish first milestone of my project: searching of definitions inside single file."}),(0,t.jsx)("h2",{className:"text-2xl pt-8 font-bold",children:"Parsing syntax tree"}),(0,t.jsxs)("p",{className:"",children:["Happily C grammar and Concrete Syntax Tree parser is already implemented in a ",(0,t.jsx)("a",{href:"https://github.com/tree-sitter/tree-sitter",children:"Tree Sitter"}),". What was left for me to do was to transform CST to second simpler tree. This is the source code we will be parsing:"]}),(0,t.jsx)("pre",{className:"mt-8",children:(0,t.jsx)("code",{className:"language-c",children:'\n\n\nstruct Address\n{                 \n    string line1; \n    string line2; \n};\n\nstruct Organization\n{\n    struct Employee\n    {                   \n        string name;    \n        string surname; \n    } emp;\n\n    int type;            \n    struct Address addr; \n};\n\nint fact(int x)\n{ \n    if (x <= 1)\n    { \n        return 1;\n    }\n    else\n        return fact(x - 1); \n};\n\nint main(int argc, char *argv[])\n{\n    int x = 1; \n\n    int y = fact(10); \n\n    struct Organization org;  \n    org.emp.name = "Dominik"; \n                              \n}\n\n'})}),(0,t.jsx)("p",{className:"mt-8",children:"And this is how Concrete Syntax Tree from Tree Sitter looks like (I wrote simple pretty-print): "}),(0,t.jsx)("pre",{className:"mt-8",children:(0,t.jsx)("code",{children:'\n|-translation_unit\n|  |-function_definition\n|  |  |-struct_specifier\n|  |  |  |-struct\n|  |  |  |-type_identifier\n|  |  |  |-field_declaration_list\n|  |  |  |  |-{\n|  |  |  |  |-field_declaration\n|  |  |  |  |  |-type_identifier\n|  |  |  |  |  |-field_identifier\n|  |  |  |  |  |-;\n|  |  |  |  |-field_declaration\n|  |  |  |  |  |-type_identifier\n|  |  |  |  |  |-field_identifier\n|  |  |  |  |  |-;\n|  |  |  |  |-}\n|  |  |-ERROR\n|  |  |  |-identifier\n|  |  |-identifier\n|  |  |-compound_statement\n|  |  |  |-{\n|  |  |  |-declaration\n|  |  |  |  |-struct_specifier\n|  |  |  |  |  |-struct\n|  |  |  |  |  |-type_identifier\n|  |  |  |  |  |-field_declaration_list\n|  |  |  |  |  |  |-{\n|  |  |  |  |  |  |-field_declaration\n|  |  |  |  |  |  |  |-type_identifier\n|  |  |  |  |  |  |  |-field_identifier\n|  |  |  |  |  |  |  |-;\n|  |  |  |  |  |  |-field_declaration\n|  |  |  |  |  |  |  |-type_identifier\n|  |  |  |  |  |  |  |-field_identifier\n|  |  |  |  |  |  |  |-;\n|  |  |  |  |  |  |-}\n|  |  |  |  |-identifier\n|  |  |  |  |-;\n|  |  |  |-declaration\n|  |  |  |  |-primitive_type\n|  |  |  |  |-identifier\n|  |  |  |  |-;\n|  |  |  |-declaration\n|  |  |  |  |-struct_specifier\n|  |  |  |  |  |-struct\n|  |  |  |  |  |-type_identifier\n|  |  |  |  |-identifier\n|  |  |  |  |-;\n|  |  |  |-}\n|  |-function_definition\n|  |  |-primitive_type\n|  |  |-function_declarator\n|  |  |  |-identifier\n|  |  |  |-parameter_list\n|  |  |  |  |-(\n|  |  |  |  |-parameter_declaration\n|  |  |  |  |  |-primitive_type\n|  |  |  |  |  |-identifier\n|  |  |  |  |-)\n|  |  |-compound_statement\n|  |  |  |-{\n|  |  |  |-if_statement\n|  |  |  |  |-if\n|  |  |  |  |-parenthesized_expression\n|  |  |  |  |  |-(\n|  |  |  |  |  |-binary_expression\n|  |  |  |  |  |  |-identifier\n|  |  |  |  |  |  |-<=\n|  |  |  |  |  |  |-number_literal\n|  |  |  |  |  |-)\n|  |  |  |  |-compound_statement\n|  |  |  |  |  |-{\n|  |  |  |  |  |-return_statement\n|  |  |  |  |  |  |-return\n|  |  |  |  |  |  |-number_literal\n|  |  |  |  |  |  |-;\n|  |  |  |  |  |-}\n|  |  |  |  |-else\n|  |  |  |  |-return_statement\n|  |  |  |  |  |-return\n|  |  |  |  |  |-call_expression\n|  |  |  |  |  |  |-identifier\n|  |  |  |  |  |  |-argument_list\n|  |  |  |  |  |  |  |-(\n|  |  |  |  |  |  |  |-binary_expression\n|  |  |  |  |  |  |  |  |-identifier\n|  |  |  |  |  |  |  |  |--\n|  |  |  |  |  |  |  |  |-number_literal\n|  |  |  |  |  |  |  |-)\n|  |  |  |  |  |-;\n|  |  |  |-}\n|  |-function_definition\n|  |  |-primitive_type\n|  |  |-function_declarator\n|  |  |  |-identifier\n|  |  |  |-parameter_list\n|  |  |  |  |-(\n|  |  |  |  |-parameter_declaration\n|  |  |  |  |  |-primitive_type\n|  |  |  |  |  |-identifier\n|  |  |  |  |-,\n|  |  |  |  |-parameter_declaration\n|  |  |  |  |  |-primitive_type\n|  |  |  |  |  |-pointer_declarator\n|  |  |  |  |  |  |-*\n|  |  |  |  |  |  |-array_declarator\n|  |  |  |  |  |  |  |-identifier\n|  |  |  |  |  |  |  |-[\n|  |  |  |  |  |  |  |-]\n|  |  |  |  |-)\n|  |  |-compound_statement\n|  |  |  |-{\n|  |  |  |-declaration\n|  |  |  |  |-primitive_type\n|  |  |  |  |-init_declarator\n|  |  |  |  |  |-identifier\n|  |  |  |  |  |-=\n|  |  |  |  |  |-number_literal\n|  |  |  |  |-;\n|  |  |  |-declaration\n|  |  |  |  |-primitive_type\n|  |  |  |  |-init_declarator\n|  |  |  |  |  |-identifier\n|  |  |  |  |  |-=\n|  |  |  |  |  |-call_expression\n|  |  |  |  |  |  |-identifier\n|  |  |  |  |  |  |-argument_list\n|  |  |  |  |  |  |  |-(\n|  |  |  |  |  |  |  |-number_literal\n|  |  |  |  |  |  |  |-)\n|  |  |  |  |-;\n|  |  |  |-declaration\n|  |  |  |  |-struct_specifier\n|  |  |  |  |  |-struct\n|  |  |  |  |  |-type_identifier\n|  |  |  |  |-identifier\n|  |  |  |  |-;\n|  |  |  |-expression_statement\n|  |  |  |  |-assignment_expression\n|  |  |  |  |  |-field_expression\n|  |  |  |  |  |  |-field_expression\n|  |  |  |  |  |  |  |-identifier\n|  |  |  |  |  |  |  |-.\n|  |  |  |  |  |  |  |-field_identifier\n|  |  |  |  |  |  |-.\n|  |  |  |  |  |  |-field_identifier\n|  |  |  |  |  |-=\n|  |  |  |  |  |-string_literal\n|  |  |  |  |  |  |-"\n|  |  |  |  |  |  |-"\n|  |  |  |  |-;\n|  |  |  |-}\n'})}),(0,t.jsxs)("p",{className:"mt-8",children:["This looks kind of scary! The first task is to extract second ",(0,t.jsx)("b",{children:"Stack Graph"})," tree which would strike good balance between correctness and simplicity. "]}),(0,t.jsx)("p",{className:"mt-8",children:"Our tree is in fact a graph or a tree with jumps. This is neccessary because we have 2 scopes in parallel: lexical scope and variable types. Navigating is like this: checking variable type, jumping to it's definition's lexical scope, taking nested member, checking it's type and so on... There are several kinds of nodes:"}),(0,t.jsxs)("ul",{className:"px-7 py-2 list-disc",children:[(0,t.jsxs)("li",{children:[(0,t.jsx)("b",{children:"NamedScope"})," - it's a struct or a function"]}),(0,t.jsxs)("li",{children:[(0,t.jsx)("b",{children:"UnnamedScope"})," - other lexical scopes"]}),(0,t.jsxs)("li",{children:[(0,t.jsx)("b",{children:"Symbol"})," - variable definition"]}),(0,t.jsxs)("li",{children:[(0,t.jsx)("b",{children:"Reference"})," - expression referring to symbol, chaining nested members"]})]}),(0,t.jsx)("p",{className:"mt-8",children:"I managed to do the parsing in simple recursive function. Thanks to passing context, it's construct is really nice and versatile and I like it. It is presented below:"}),(0,t.jsxs)("figure",{className:"mt-10",children:[(0,t.jsx)("img",{alt:"Node Parser",src:"/clang-1.png",width:"80%",height:"80%"}),(0,t.jsx)("figcaption",{className:"font-bold text-center",children:"Declaration of parsing method"})]}),(0,t.jsx)("p",{className:"mt-8",children:"First I accumulate nodes on the stack, lexical scope pushes to the stack and on the end pops from the stack. Second there is reference to the source code from which we take identifiers. Third each recursive invocation has current node on any level. And the fourth part is crucial. I was able micmic state machine while recursing by passing a string state, which was needed in couple of cases. And sometimes I needed to get jump from subtree and passing context by reference allows that. So this function recursively visits the tree sitter tree and leaves on stack my tree that looks like this: "}),(0,t.jsx)("pre",{className:"mt-8",children:(0,t.jsx)("code",{children:"\n|-NAMED_SCOPE[translation_unit]\n|  |-NAMED_SCOPE[Address]\n|  |  |-SYMBOL[line1]~> root\n|  |  |-SYMBOL[line2]~> root\n|  |-NAMED_SCOPE[Organization]\n|  |  |-NAMED_SCOPE[Employee]\n|  |  |  |-SYMBOL[name]~> root\n|  |  |  |-SYMBOL[surname]~> root\n|  |  |-SYMBOL[emp]~> Employee\n|  |  |-SYMBOL[type]~> root\n|  |  |-SYMBOL[Address]~> Address\n|  |  |-SYMBOL[addr]~> Address\n|  |-NAMED_SCOPE[fact]\n|  |  |-SYMBOL[x]~> root\n|  |  |-REFERENCE[x]\n|  |  |-REFERENCE[fact]\n|  |-NAMED_SCOPE[main]\n|  |  |-SYMBOL[argc]~> root\n|  |  |-SYMBOL[argv]~> root\n|  |  |-SYMBOL[x]~> root\n|  |  |-SYMBOL[y]~> root\n|  |  |-REFERENCE[fact]\n|  |  |-SYMBOL[Organization]~> Organization\n|  |  |-SYMBOL[org]~> Organization\n|  |  |-REFERENCE[org.emp.name]\n"})}),(0,t.jsx)("h2",{className:"text-2xl pt-14 font-bold",children:"Engine"}),(0,t.jsxs)("p",{className:"",children:['Now that we have a tree ready, the engine is quite simple. Each time we want to look up reference we load it on stack. Stack is represented as string with dots between the parts. True, we can have also pointer derefrences and expressions can be really complex but I wanted to have simple solution. So the reference is always sanitized to "canonical" form. Now we take first part ',(0,t.jsx)("b",{children:"org"})," from the stack. We incrementally search parents and their children to search for this symbol. We find it. Now we have a symbol and each symbol has ",(0,t.jsx)("b",{children:"jump"})," to type, so it takes us to the ",(0,t.jsx)("b",{children:"Organization"}),". There we pop next part ",(0,t.jsx)("b",{children:"emp"})," and in it's children we found such symbol. Now jump takes us to the ",(0,t.jsx)("b",{children:"Employee"})," and finally we pop name. The stack is empty and position of ",(0,t.jsx)("b",{children:"name"})," is returned "]}),(0,t.jsx)("pre",{className:"p-5",children:(0,t.jsx)("code",{children:"\nLooking up reference\nStack: org.emp.name\nStack: emp.name\nNode Jump\nStack: emp.name\nNode Jump\nStack: emp.name\nStack: name\nNode Jump\nStack: name\nStack: \n"})}),(0,t.jsxs)("p",{className:"mt-8",children:["You can find the code of all 4 parts ",(0,t.jsx)("a",{href:"https://github.com/dgawlik/c-language-server",children:"here"}),". In next post I will present how to link multiple files together. Thanks for reading."]})]})]})})}},9008:function(e,n,i){e.exports=i(5443)}},function(e){e.O(0,[774,888,179],(function(){return n=8664,e(e.s=n);var n}));var n=e.O();_N_E=n}]);