"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[630],{3374:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>r,metadata:()=>a,toc:()=>u});var a=t(1754),i=t(4848),s=t(8453);const r={title:"1BRC Challenge",tags:["java","optimization"]},o="1BRC Challenge",l={authorsImageUrls:[]},u=[{value:"Baseline",id:"baseline",level:2},{value:"Parallelizing the code",id:"parallelizing-the-code",level:2},{value:"Optimizations",id:"optimizations",level:2},{value:"O1. Reading longs instead of bytes",id:"o1-reading-longs-instead-of-bytes",level:3},{value:"O2. Represent measurements as int / skip parsing",id:"o2-represent-measurements-as-int--skip-parsing",level:3},{value:"O3. Defer creating of String",id:"o3-defer-creating-of-string",level:3},{value:"O4. Faster hashes",id:"o4-faster-hashes",level:3},{value:"O5. Skipping synchronization",id:"o5-skipping-synchronization",level:3},{value:"O6. Off heap memory",id:"o6-off-heap-memory",level:3},{value:"07. Aligning array address to the multitude of 8 bytes",id:"07-aligning-array-address-to-the-multitude-of-8-bytes",level:3},{value:"Final version",id:"final-version",level:3},{value:"Conclusion",id:"conclusion",level:2}];function h(e){const n={code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"One thing that recently got nerd the hell out of me was 1 billion row challenge. Citing the original site:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"Your mission, should you decide to accept it, is deceptively simple: write a Java program for retrieving temperature measurement values from a text file and calculating the min, mean, and max temperature per weather station. There\u2019s just one caveat: the file has 1,000,000,000 rows!"})}),"\n",(0,i.jsx)(n.p,{children:"I was working on it after hourse and 1 week after taking on the challenge there are several conclusions worth writing about."}),"\n",(0,i.jsx)(n.h2,{id:"baseline",children:"Baseline"}),"\n",(0,i.jsx)(n.p,{children:"To make dev loop faster I decided limit the task to 100 million rows."}),"\n",(0,i.jsx)(n.p,{children:"The baseline from the autor was an idiomatic streams, but single threaded."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'public class CalculateAverage_baseline {\n\n    private static final String FILE = "./measurements.txt";\n\n    private static record Measurement(String station, double value) {\n        private Measurement(String[] parts) {\n            this(parts[0], Double.parseDouble(parts[1]));\n        }\n    }\n\n    private static record ResultRow(double min, double mean, double max) {\n\n        public String toString() {\n            return round(min) + "/" + round(mean) + "/" + round(max);\n        }\n\n        private double round(double value) {\n            return Math.round(value * 10.0) / 10.0;\n        }\n    };\n\n    private static class MeasurementAggregator {\n        private double min = Double.POSITIVE_INFINITY;\n        private double max = Double.NEGATIVE_INFINITY;\n        private double sum;\n        private long count;\n    }\n\n    public static void main(String[] args) throws IOException {\n\n        Collector<Measurement, MeasurementAggregator, ResultRow> collector = Collector.of(\n                MeasurementAggregator::new,\n                (a, m) -> {\n                    a.min = Math.min(a.min, m.value);\n                    a.max = Math.max(a.max, m.value);\n                    a.sum += m.value;\n                    a.count++;\n                },\n                (agg1, agg2) -> {\n                    var res = new MeasurementAggregator();\n                    res.min = Math.min(agg1.min, agg2.min);\n                    res.max = Math.max(agg1.max, agg2.max);\n                    res.sum = agg1.sum + agg2.sum;\n                    res.count = agg1.count + agg2.count;\n\n                    return res;\n                },\n                agg -> {\n                    return new ResultRow(agg.min, (Math.round(agg.sum * 10.0) / 10.0) / agg.count, agg.max);\n                });\n\n        Map<String, ResultRow> measurements = new TreeMap<>(Files.lines(Paths.get(FILE))\n                .map(l -> new Measurement(l.split(";")))\n                .collect(groupingBy(m -> m.station(), collector)));\n\n        System.out.println(measurements);\n    }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"The performance is not good as expected:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"time ./calculate_average_baseline.sh \n\nreal    0m15,846s\nuser    0m16,002s\nsys     0m0,769s\n"})}),"\n",(0,i.jsx)(n.h2,{id:"parallelizing-the-code",children:"Parallelizing the code"}),"\n",(0,i.jsx)(n.p,{children:"My first thought was to parallelize the code and see how fast it will run. Obvious choice is to use streams the same way but add .parallel() call. So updates go to central HashMap and access has to be synchronized."}),"\n",(0,i.jsx)(n.p,{children:"One way is to use locks, tried it and it was slow. Remembering we have 100 million rows locking on whole object is very wasteful. Much better would be to lock only on specific hashmap entry with given key."}),"\n",(0,i.jsx)(n.p,{children:"What surprised me was that Atomic* primitives and spinlocks were actually slower than wait/notify. Luckly there is another way you can do same thing with ConcurrentHashMap. When calling compute method the run lambda will be synchronized."}),"\n",(0,i.jsx)(n.p,{children:"So the code reads file on the fly and uses Spliterator to carve out overflow of work to another thread run on ForkJoinPool. Then each iteration of foreach does the update on ConcurrentHashMap."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'public class CalculateAverage_dg2 {\n\n    private static final String FILE = "./measurements.txt";\n\n    private static class Measurement {\n        public double min = Double.MAX_VALUE;\n        public double max = Double.MIN_VALUE;\n        public double sum = 0;\n        public double count = 0;\n\n        public Measurement(double value) {\n            this.min = value;\n            this.max = value;\n            this.sum = value;\n            this.count = 1;\n        }\n\n        @Override\n        public String toString() {\n            return round(min) + "/" + round(max) + "/" + round(sum / count);\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n\n        ConcurrentHashMap<String, Measurement> measurements = new ConcurrentHashMap<>();\n\n        Files.lines(Path.of(FILE)).parallel().forEach(line -> {\n\n            int split = line.indexOf(";");\n            String key = line.substring(0, split);\n            double val = Double.parseDouble(line.substring(split + 1));\n\n            measurements.compute(key, (k, _v) -> {\n                if (_v == null) {\n                    return new Measurement(val);\n                }\n\n                _v.min = Double.min(_v.min, val);\n                _v.max = Double.max(_v.max, val);\n\n                _v.sum += val;\n                _v.count++;\n\n                return _v;\n            });\n        });\n\n        var sorted = new TreeMap<>(measurements);\n\n        System.out.println(sorted);\n\n    }\n\n    private static double round(double value) {\n        return Math.round(value * 10.0) / 10.0;\n    }\n\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"The results were good - on 4 core (8 threads) CPU it runs 4 times faster:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"time ./calculate_average_dg2.sh \nreal    0m4,992s\nuser    0m33,384s\nsys     0m1,207s\n"})}),"\n",(0,i.jsx)(n.p,{children:'Spliterators performance is good because of data locality that it preserves. Processors have limited amount of L1/L2/L3 caches so if you don\'t keep the data close to computation then this translates to cache missess. So best way is to perform operations "semi-sequentially" just like the spliterators.'}),"\n",(0,i.jsx)(n.p,{children:"But... Streams create threads dynamically and this means you can't partition the data into well known parts. So the access has to be synchronized in one place and this one big problem here."}),"\n",(0,i.jsx)(n.p,{children:"It would be the end of the story if I didn't check the leaderboard on competitions github repo. There were speedups as fast as astonishing 32x times faster. So there is much to analyse. Below are the most important optimizations I tried in my playground."}),"\n",(0,i.jsx)(n.h2,{id:"optimizations",children:"Optimizations"}),"\n",(0,i.jsx)(n.h3,{id:"o1-reading-longs-instead-of-bytes",children:"O1. Reading longs instead of bytes"}),"\n",(0,i.jsx)(n.p,{children:"You may recall that everything is represented in JVM as an int. This means that even a byte is in fact and 4-byte int. I'm not sure if JVM doesn't do some kind of compression of byte[] array. If not that would mean the data is actually 4x times larager. So it is wasteful to search newline byte by byte. The trick is to load 8 bytes at once and find newline in whole batch."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:" long word = buffer.getLong();\n\nlong match = word ^ 0x0a0a0a0a0a0a0a0aL;\nlong line = (match - 0x0101010101010101L) & (~match & 0x8080808080808080L);\n\nif (line == 0) {\n    i += 8;\n    continue;\n}\n\nnext = i + (Long.numberOfTrailingZeros(line) >>> 3) + 1;\n"})}),"\n",(0,i.jsx)(n.p,{children:"Xor will zero the byte that has newline (0x0a). Then we cause underflow which sets leading bit to 1. And then we zero out everthing else. From the leading bit we can get offset of newline in 8-byte pack."}),"\n",(0,i.jsx)(n.h3,{id:"o2-represent-measurements-as-int--skip-parsing",children:"O2. Represent measurements as int / skip parsing"}),"\n",(0,i.jsx)(n.p,{children:"We can take advantage of the data format: floats have only one decimal point and temperatures are not greater or lesser than 100 points for sure. So the idea is to parse the number manually and multiply it by 10 so that it is the integer."}),"\n",(0,i.jsx)(n.p,{children:"This is not huge improvement but still. Actually big improvement is skipping Double.parseDouble as we can discard uncessary complexity like long mantissa and exponent part."}),"\n",(0,i.jsx)(n.h3,{id:"o3-defer-creating-of-string",children:"O3. Defer creating of String"}),"\n",(0,i.jsx)(n.p,{children:"Strings are a little bit heavy because they are not underlied by byte[] but char[]. So each time we create a string we encode it and according to the charset. We can defer creating strings until they are needed for printing. But we have to find some other key for the hashmap."}),"\n",(0,i.jsx)(n.p,{children:"Copying byte array is much faster and this is what I used."}),"\n",(0,i.jsx)(n.h3,{id:"o4-faster-hashes",children:"O4. Faster hashes"}),"\n",(0,i.jsx)(n.p,{children:"Faster non-cryptographic hash is needed. One suitable algorithm for this task is FNV. It is simple enought to implement and run fast."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"@Override\npublic int hashCode() {\n    long hash = 0x811C9DC5;\n    long prime = 0x01000193;\n\n    for (byte b : bytes) {\n        hash = hash ^ b;\n        hash *= prime;\n    }\n\n    return (int) hash;\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"o5-skipping-synchronization",children:"O5. Skipping synchronization"}),"\n",(0,i.jsx)(n.p,{children:"With such huge load synchronization is too slow. It is fine from more coarse grained control flow, but 100 million is just too much. So optimization is to use separate threads each with separate hashmap. Then merge hashmaps after the work is done. As number of hashmaps will be several orders of magnitude less than rows then merging time will be negligible."}),"\n",(0,i.jsx)(n.h3,{id:"o6-off-heap-memory",children:"O6. Off heap memory"}),"\n",(0,i.jsx)(n.p,{children:'We could use Unsafe to skip array bounds checking for example. But much better way is avoid allocating data on the heap alltogether. With mapping file chunks directly to memory we can easily achieve that. We get MemorySegment and invoke methods which are "native" to get fast access.'}),"\n",(0,i.jsx)(n.h3,{id:"07-aligning-array-address-to-the-multitude-of-8-bytes",children:"07. Aligning array address to the multitude of 8 bytes"}),"\n",(0,i.jsx)(n.p,{children:"There is performance penalty for accessing unaligned data, which has to be padded either way. So we can remap all the data in segment once and then enjoy the benefits of reading values in multitudes of 8-bytes (longs)."}),"\n",(0,i.jsx)(n.h3,{id:"final-version",children:"Final version"}),"\n",(0,i.jsx)(n.p,{children:"The final version uses all above techniques and gets decent peformance. The file is split into 100MB chunks which are memory mapped by each thread. They are executed in form of ForkJoinPool task and run on common pool which has concurrency level same as numer of threads."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"class Measurement {\n    public int min = Integer.MAX_VALUE;\n    public int max = Integer.MIN_VALUE;\n    public int sum = 0;\n    public int count = 0;\n\n    public Measurement(int value) {\n        this.min = value;\n        this.max = value;\n        this.sum = value;\n        this.count = 1;\n    }\n\n    @Override\n    public String toString() {\n        return round(min / 10.0) + \"/\" + round(max / 10.0) + \"/\" + round((sum / 10.0) / count);\n    }\n\n    private static double round(double value) {\n        return Math.round(value * 10.0) / 10.0;\n    }\n\n}\n\nclass FastKey implements Comparable<FastKey> {\n    private byte[] bytes;\n    private int hash;\n\n    private static final Charset charset = Charset.forName(\"UTF-8\");\n\n    public FastKey(MemorySegment segment) {\n        bytes = segment.toArray(ValueLayout.OfByte.JAVA_BYTE);\n\n        long hash = 0x811C9DC5;\n        long prime = 0x01000193;\n\n        for (byte b : bytes) {\n            hash = hash ^ b;\n            hash *= prime;\n        }\n\n        this.hash = (int) hash;\n    }\n\n    @Override\n    public int hashCode() {\n        return this.hash;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n\n        if (!(obj instanceof FastKey)) {\n            return false;\n        }\n\n        return Arrays.equals(bytes, ((FastKey) obj).bytes);\n    }\n\n    @Override\n    public int compareTo(FastKey o) {\n        return Arrays.compare(bytes, o.bytes);\n    }\n\n    @Override\n    public String toString() {\n        return new String(bytes, charset);\n    }\n}\n\nclass ComputeMeasurementsPartTask implements Callable<Map<FastKey, Measurement>> {\n\n    private int start;\n    private int end;\n    private static final Charset charset = Charset.forName(\"UTF-8\");\n    private MemorySegment segment;\n\n    private byte getByte(int index) {\n        return segment.get(ValueLayout.OfByte.JAVA_BYTE, index);\n    }\n\n    private long getLong(int index) {\n        return segment.get(ValueLayout.OfLong.JAVA_LONG, index);\n    }\n\n    public ComputeMeasurementsPartTask(int start, int end, int limit, FileChannel channel) throws IOException {\n\n        this.segment = channel.map(FileChannel.MapMode.READ_ONLY, start, limit - start, Arena.global());\n        int s = start, s2 = start, e = end;\n\n        if (s != 0) {\n            while (getByte(s - s2) != 0x0a) {\n                s++;\n            }\n            s++;\n        }\n\n        while (e < limit && getByte(e - s2) != 0x0a) {\n            e++;\n        }\n\n        int prefix = s % 8;\n        MemorySegment padded = Arena.global().allocate(e - s + prefix);\n        padded.asSlice(prefix).copyFrom(segment.asSlice(s - s2, e - s));\n\n        this.segment = padded;\n        this.start = prefix;\n        this.end = e - s + prefix;\n    }\n\n    private void doActualWork(int start, int end, Map<FastKey, Measurement> measurements) {\n\n        int splitIndex = start;\n        while (getByte(splitIndex) != 0x3b) {\n            splitIndex++;\n        }\n\n        var key = new FastKey(segment.asSlice(start, splitIndex - start));\n\n        boolean negative = false;\n        int ind = splitIndex + 1;\n\n        if (getByte(ind) == (byte) '-') {\n            negative = true;\n            ind++;\n        }\n\n        int v = 0;\n\n        if (end - ind == 4) {\n            v = v * 10 + getByte(ind++) - '0';\n            v = v * 10 + getByte(ind++) - '0';\n            ind++; // '.'\n            v = v * 10 + getByte(ind) - '0';\n        }\n        else {\n            v = getByte(ind++) - '0';\n            ind++; // '.'\n            v = v * 10 + getByte(ind) - '0';\n        }\n\n        int val = negative ? -v : v;\n\n        var _v = measurements.get(key);\n\n        if (_v != null) {\n            if (val < _v.min) {\n                _v.min = val;\n            }\n\n            if (val > _v.max) {\n                _v.max = val;\n            }\n\n            _v.sum += val;\n            _v.count++;\n        }\n        else {\n            measurements.put(key, new Measurement(val));\n        }\n    }\n\n    @Override\n    public Map<FastKey, Measurement> call() throws Exception {\n        var measurements = new HashMap<FastKey, Measurement>();\n\n        int prev = start;\n        for (int i = 0; i < end; i += 8) {\n            if (i + 8 < end) {\n                long word = getLong(i);\n\n                long match = word ^ 0x0a0a0a0a0a0a0a0aL;\n                long line = (match - 0x0101010101010101L) & (~match & 0x8080808080808080L);\n\n                if (line == 0) {\n                    i += 8;\n                    continue;\n                }\n                int next = i + (Long.numberOfTrailingZeros(line) >>> 3);\n                doActualWork(prev, next, measurements);\n                prev = next + 1;\n            }\n            else {\n                doActualWork(prev, end, measurements);\n            }\n\n        }\n\n        return measurements;\n    }\n}\n\npublic class CalculateAverage_dg {\n\n    public static final String FILE = \"./measurements.txt\";\n\n    public static void main(String[] args) throws Exception {\n\n        FileChannel channel = FileChannel.open(Path.of(CalculateAverage_dg.FILE), StandardOpenOption.READ);\n\n        var parts = new ArrayList<Map<FastKey, Measurement>>();\n        var futures = new ArrayList<Future<Map<FastKey, Measurement>>>();\n\n        int fileSize = (int) Files.size(Path.of(FILE));\n        int chunkSize = 20 * 1024 * 1024;\n        int noOfThreads = fileSize / chunkSize;\n\n        for (int i = 0; i < noOfThreads; i++) {\n            int start = i * chunkSize;\n            int end = Math.min((i + 1) * chunkSize, fileSize);\n            int limit = Math.min((i + 1) * chunkSize + 1024, fileSize);\n\n            var task = new ComputeMeasurementsPartTask(start, end, limit, channel);\n            futures.add(ForkJoinPool.commonPool().submit(task));\n        }\n\n        for (var future : futures) {\n            parts.add(future.get());\n        }\n\n        var measurements = parts.stream().flatMap(map -> map.entrySet().stream())\n                .collect(\n                        Collectors.toMap(\n                                Map.Entry::getKey,\n                                Map.Entry::getValue,\n                                (e1, e2) -> {\n                                    e1.min = Integer.min(e1.min, e2.min);\n                                    e1.max = Integer.max(e1.max, e2.max);\n\n                                    e1.sum += e2.sum;\n                                    e1.count += e2.count;\n\n                                    return e1;\n                                }));\n\n        var sorted = new TreeMap<>(measurements);\n\n        System.out.println(sorted);\n\n    }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"The time is impressive:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"time ./calculate_average_dg.sh \n\nreal    0m1,465s\nuser    0m8,505s\nsys     0m0,526s\n"})}),"\n",(0,i.jsx)(n.p,{children:"For comparison this is the time of top solution from the leaderboard."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"time ./calculate_average_thomaswue.sh \n\nreal    0m0,794s\nuser    0m5,032s\nsys     0m0,199s\n"})}),"\n",(0,i.jsx)(n.p,{children:'So it is "only" two times slower than the best. I don\'t know how would that translate to the leaderboard. But this guy is actually founder of GraalVM so he definitely knows what he is doing.'}),"\n",(0,i.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"ConcurrentHashMap is suprisingly fast, without good background it would be hard to write something faster"}),"\n",(0,i.jsx)(n.li,{children:"Off-heap memory gives considerable performance boost"}),"\n",(0,i.jsx)(n.li,{children:"Reading file as longs is a nice trick that I didn't know up to date"}),"\n"]})]})}function c(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var a=t(6540);const i={},s=a.createContext(i);function r(e){const n=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),a.createElement(s.Provider,{value:n},e.children)}},1754:e=>{e.exports=JSON.parse('{"permalink":"/blog/2024/10/29/","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2024-10-29.md","source":"@site/blog/2024-10-29.md","title":"1BRC Challenge","description":"One thing that recently got nerd the hell out of me was 1 billion row challenge. Citing the original site:","date":"2024-10-29T00:00:00.000Z","tags":[{"inline":true,"label":"java","permalink":"/blog/tags/java"},{"inline":true,"label":"optimization","permalink":"/blog/tags/optimization"}],"readingTime":11.025,"hasTruncateMarker":true,"authors":[],"frontMatter":{"title":"1BRC Challenge","tags":["java","optimization"]},"unlisted":false,"prevItem":{"title":"Reflections after writing simple Spring Boot library","permalink":"/blog/2024/11/5/"},"nextItem":{"title":"Topology graphs are important (and fun)","permalink":"/blog/2024/10/26/"}}')}}]);