"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[2404],{8249:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>d});var r=i(2794),t=i(4848),s=i(8453);const a={title:"Semantic search for dynamically built queries in Java and CodeQL",tags:["codeql","java","sql"]},o="Semantic search for dynamically built queries in Java and CodeQL",l={authorsImageUrls:[]},d=[{value:"CodeQL setup",id:"codeql-setup",level:2},{value:"The challenge",id:"the-challenge",level:2},{value:"Approximate solution",id:"approximate-solution",level:2},{value:"Exact solution",id:"exact-solution",level:2},{value:"Conclusion",id:"conclusion",level:2}];function c(e){const n={a:"a",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"There was a challenge for me recently to search for SQL queries in large codebase. There is a problem\nwith using basic grep or even IntelliJ search here because of the performance issues."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"queries are long and dynamically appended"}),"\n",(0,t.jsx)(n.li,{children:"codebase is large"}),"\n",(0,t.jsx)(n.li,{children:"string searching is not performant enough."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"An answer how to solve this task is buried in history of beginnings of static analysis tools. The first tools\nused basic regexes, but that turned out inefficient pretty quickly. Then incrementally more focus has been\nput to parse source files to Abstract Syntax Trees which is allows more freedom to write queries. Then\nfinally Data Flow approach was added alongside Taint Analysis to make current landscape of security today."}),"\n",(0,t.jsx)(n.p,{children:"Semantic searching has 2 advantages:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"searching bare tokens is orders of magnitude faster than strings, in turn searching Abstract Syntax Trees\nis order of magnitude faster than tokens"}),"\n",(0,t.jsx)(n.li,{children:"semantic search offers more precision in designing the queries which only reinforces the first point."}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"CodeQL"})," is one such tool that knows the syntax of major languages (Java) and caters for performant search of\nlarge codebases. I decided to have fun with it over the weekend and push it to it's limits as searching for\ndynamic queries is hard enough. I will show how to set up the project and write some queries for toy source file."]}),"\n",(0,t.jsx)(n.p,{children:"Let's get started."}),"\n",(0,t.jsx)(n.h2,{id:"codeql-setup",children:"CodeQL setup"}),"\n",(0,t.jsxs)(n.p,{children:["First step is downloading ",(0,t.jsx)(n.a,{href:"https://docs.github.com/en/code-security/codeql-cli/getting-started-with-the-codeql-cli/setting-up-the-codeql-cli",children:"CLI"})," and setting it up in a PATH."]}),"\n",(0,t.jsxs)(n.p,{children:["Then you have to build ",(0,t.jsx)(n.strong,{children:"database"})," for the project you will be analyzing. Unfortunately on each code change you have to rebuid it."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"codeql database create --source-root=. --language=java-kotlin --command='./mvnw clean compile' -- tester\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"--source-root"})," - it is used for reporting in queries which give you source locations"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"--language"})," - if you want to limit project just to one language, this is an option"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"--command"})," - codeQL tracks work of build tool to extract AST and DataFlow information"]}),"\n",(0,t.jsx)(n.p,{children:"Then in next step download VSCode extension."}),"\n",(0,t.jsxs)(n.p,{children:["Select ",(0,t.jsx)(n.strong,{children:"QL"})," on the sidebar."]}),"\n",(0,t.jsx)(n.p,{children:"Lanugage > set Java."}),"\n",(0,t.jsx)(n.p,{children:"Databases > From a folder > point to database folder you have built."}),"\n",(0,t.jsx)(n.p,{children:"Ctrl+Shift+p > CodeQL: create query"}),"\n",(0,t.jsx)(n.p,{children:"And you are good to go."}),"\n",(0,t.jsx)(n.h2,{id:"the-challenge",children:"The challenge"}),"\n",(0,t.jsx)(n.p,{children:"We will be operating on Spring Boot project, but of interest is one file only really."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'package com.example.demo.database;\n\nimport java.util.List;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.jdbc.core.JdbcTemplate;\nimport org.springframework.stereotype.Service;\n\nimport com.example.demo.valueobject.Purchasing1;\n\n@Service\npublic class WWRepository1 {\n   \n   @Autowired\n   private JdbcTemplate jdbcTemplate;\n\n   public List<Purchasing1> getAllPurchasing() {\n        \n        StringBuilder aside = new StringBuilder();\n        aside.append("Hello ");\n        aside.append("World");\n        aside.append("!");\n\n        System.out.println(aside.toString());\n\n\n        StringBuilder sql = new StringBuilder();\n        sql.append("SELECT Description, SupplierName, BankAccountName, ValidFrom, ValidTo ");\n        sql.append("FROM Purchasing.PurchaseOrders o ");\n        addJoin1(sql);\n        addJoin2(sql);\n\n        return jdbcTemplate.query(sql.toString(), (rs, rowNum) -> \n             new Purchasing1(\n                rs.getString("Description"), \n                rs.getString("SupplierName"), \n                rs.getString("BankAccountName"), \n                rs.getTimestamp("ValidFrom").toLocalDateTime(), \n                rs.getTimestamp("ValidTo").toLocalDateTime()\n            )\n        );\n   }\n\n   private void addJoin1(StringBuilder sb) {\n       sb.append("inner join Purchasing.PurchaseOrderLines l on o.PurchaseOrderID = l.PurchaseOrderID ");\n   }\n\n   private void addJoin2(StringBuilder sb) {\n      sb.append("inner join Purchasing.Suppliers s on s.SupplierID = o.SupplierID");\n   }\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"Let's make some assumptions:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"codebase is tens of thousands files, but query building is local to single file"}),"\n",(0,t.jsxs)(n.li,{children:["queries are built with ",(0,t.jsx)(n.strong,{children:"StringBuilder"})," but there can be some noise like unrelated ",(0,t.jsx)(n.strong,{children:"appends"})]}),"\n",(0,t.jsxs)(n.li,{children:['query is "finalized* with passing it to ',(0,t.jsx)(n.strong,{children:"jdbcTemplate"})]}),"\n",(0,t.jsx)(n.li,{children:"query building can be nested in helper methods which can further nest the logic"}),"\n",(0,t.jsx)(n.li,{children:"query searching has to be case insensitive"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"approximate-solution",children:"Approximate solution"}),"\n",(0,t.jsx)(n.p,{children:"My logic here is the following. Having a file of the given query is good enough, even having false positives.\nSo let's assume that the file is valid if it has all the query chunks. For example WWRepository1.java is valid\nbecause it has:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"SELECT Description, SupplierName, BankAccountName, ValidFrom, ValidTo\n"})}),"\n",(0,t.jsx)(n.p,{children:"or"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"FROM Purchasing.PurchaseOrders o \n"})}),"\n",(0,t.jsx)(n.p,{children:"or"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"inner join Purchasing.PurchaseOrderLines l on o.PurchaseOrderID = l.PurchaseOrderID\n"})}),"\n",(0,t.jsx)(n.p,{children:"or"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"inner join Purchasing.Suppliers s on s.SupplierID = o.SupplierID\n"})}),"\n",(0,t.jsx)(n.p,{children:"A limitation of this approach is that if we have 2 queries in one file, they could intermix and\ngive a false positive, but let's not worry about that for now."}),"\n",(0,t.jsx)(n.p,{children:"Let's write first CodeQL query."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'from \n    MethodCall e,\n    Expr part \nwhere \n    e.getMethod().hasName("append") \n    and e.getQualifier().getType().hasName("StringBuilder")\n    and part = e.getArgument(0)\n    and (part.toString().matches("%SELECT Description, SupplierName, BankAccountName, ValidFrom, ValidTo%")\n       or part.toString().matches("%FROM Purchasing.PurchaseOrders%")\n       or part.toString().matches("%inner join Purchasing.PurchaseOrderLines%")\n       or part.toString().matches("%inner join Purchasing.Suppliers%")\n    )\nselect e.getFile()\n'})}),"\n",(0,t.jsx)(n.p,{children:"And we get one file which is correct. CodeQL is purely declarative that allows to treat AST element like a table in\nitself."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"from \n    MethodCall e,\n    Expr part \n"})}),"\n",(0,t.jsx)(n.p,{children:"Find any method call and any expression in the database."}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:'e.getMethod().hasName("append")'})," - we are targeting appends"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:'e.getQualifier().getType().hasName("StringBuilder")'})," - the target type is StringBuilder"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"part = e.getArgument(0)"})," - limit part expression to be first argument of our append"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:'part.toString().matches("%FROM Purchasing.PurchaseOrders%")'})," - first argument serialized to string has this label"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"e.getFile()"})," - get enclosing file"]}),"\n",(0,t.jsx)(n.p,{children:"Now that we found something let's refine the query to be more accurate."}),"\n",(0,t.jsx)(n.h2,{id:"exact-solution",children:"Exact solution"}),"\n",(0,t.jsxs)(n.p,{children:["So far we used pure AST based queries, but a nice feature of ",(0,t.jsx)(n.strong,{children:"CodeQL"})," is that allows to analyze data flow\ninside the codebase. It's has it's limitations though - you can't just compute the expression for a method for\nexample as that would mean running the program. You can however order instructions in codebase in happens-before\nrelation which is good enough to refine our query."]}),"\n",(0,t.jsx)(n.p,{children:"CodeQL has 2 variants: Local DataFlow and Global DataFlow. It turns out that local variant is presupposed to be\nused on simple expressions and does not track variables across method calls. So we will use global option (I have\nno idea how long it runs for medium sized projects)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'import java\nimport semmle.code.java.dataflow.DataFlow\n\n\n  module FindQueryConfig implements DataFlow::ConfigSig {\n    predicate isSource(DataFlow::Node source) {\n      exists (MethodCall jdbcQuery, MethodCall toString |\n            jdbcQuery.getMethod().hasName("query") and\n            jdbcQuery.getArgument(0) = toString and \n            toString.getMethod().hasName("toString") and\n            DataFlow::localFlow(DataFlow::exprNode(source.asExpr()), \n                 DataFlow::exprNode(toString.getQualifier()))\n        )\n    }\n  \n    predicate isSink(DataFlow::Node sink) {\n       sink.asExpr().(MethodCall).getMethod().hasName("append")\n       and exists (Expr argument |\n            argument = sink.asExpr().(MethodCall).getArgument(0)\n            and (argument.toString().matches("%SELECT Description, SupplierName, BankAccountName, ValidFrom, ValidTo%")\n            or argument.toString().matches("%FROM Purchasing.PurchaseOrders%")\n            or argument.toString().matches("%inner join Purchasing.PurchaseOrderLines%")\n            or argument.toString().matches("%inner join Purchasing.Suppliers%"))\n        )\n    }\n  }\n  \n  module FindQuery = DataFlow::Global<FindQueryConfig>;\n  \n  from DataFlow::Node src, DataFlow::Node sink\n  where FindQuery::flow(src, sink)\n  select src, "This environment variable constructs a URL $@.", sink, "here"\n'})}),"\n",(0,t.jsx)(n.p,{children:"In essence dataflow is represented as ordered instructions coming from source to sink. There is only\none sink and from it all preceding instructions are considered. Then these 2 variables can be further\nmatched in query to limit the search."}),"\n",(0,t.jsxs)(n.p,{children:["This query is considering as sink any expression that ultimately lands in ",(0,t.jsx)(n.code,{children:"jdbc.query"})," as an argument so"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'StringBuilder aside = new StringBuilder();\naside.append("Hello ");\naside.append("World");\naside.append("!");\n'})}),"\n",(0,t.jsx)(n.p,{children:"this won't be matched as false positive."}),"\n",(0,t.jsx)(n.p,{children:"The sink is any append expression that takes familiar labels from the previous part."}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"predicate"})," - this is the function that takes any arguments and returns boolean, it is\ndesigned to offload heavy logic from your main query to selfcontained part"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"exists"})," - it is a subquery that matches if any of the records exists, before the bar ",(0,t.jsx)(n.code,{children:"|"}),'\nyou write "free variables" and after some condition like in predicate']}),"\n",(0,t.jsx)(n.p,{children:"Then final lines is the flow execution. Little nuisance is that instead of single file it will\ngive you all code paths to the sinks. But clicking any of the links takes you to the file anyway."}),"\n",(0,t.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,t.jsx)(n.p,{children:"CodeQL is rich and mature tool. I only uncovered the tip of an iceberg for a specific use case.\nIf you are interested you can:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"read the documentation or github blog posts"}),"\n",(0,t.jsx)(n.li,{children:"read index of all combinators"}),"\n",(0,t.jsx)(n.li,{children:"read security rules written on top of it"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Further reading"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://github.blog/developer-skills/github/codeql-zero-to-hero-part-1-the-fundamentals-of-static-analysis-for-vulnerability-research/",children:"CodeQL zero to hero: part 1"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://github.blog/developer-skills/github/codeql-zero-to-hero-part-2-getting-started-with-codeql/",children:"CodeQL zero to hero: part 2"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://github.blog/security/vulnerability-research/codeql-zero-to-hero-part-3-security-research-with-codeql/",children:"CodeQL zero to hero: part 3"})}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>o});var r=i(6540);const t={},s=r.createContext(t);function a(e){const n=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),r.createElement(s.Provider,{value:n},e.children)}},2794:e=>{e.exports=JSON.parse('{"permalink":"/blog/2025/03/9/","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2025-03-9.md","source":"@site/blog/2025-03-9.md","title":"Semantic search for dynamically built queries in Java and CodeQL","description":"There was a challenge for me recently to search for SQL queries in large codebase. There is a problem","date":"2025-03-09T00:00:00.000Z","tags":[{"inline":true,"label":"codeql","permalink":"/blog/tags/codeql"},{"inline":true,"label":"java","permalink":"/blog/tags/java"},{"inline":true,"label":"sql","permalink":"/blog/tags/sql"}],"readingTime":6.33,"hasTruncateMarker":true,"authors":[],"frontMatter":{"title":"Semantic search for dynamically built queries in Java and CodeQL","tags":["codeql","java","sql"]},"unlisted":false,"nextItem":{"title":"Wring simple parser with Megaparsec in Haskell","permalink":"/blog/2025/03/3/"}}')}}]);