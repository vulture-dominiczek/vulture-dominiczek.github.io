"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[995],{6563:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>a,metadata:()=>o,toc:()=>c});var o=t(98),r=t(4848),i=t(8453);const a={title:"Writing own Kubernetes operator in Java",tags:["k8s","java","devops"]},s="Writing own Kubernetes operator in Java",l={authorsImageUrls:[]},c=[{value:"Anatomy of an operator",id:"anatomy-of-an-operator",level:2},{value:"Control loop",id:"control-loop",level:4},{value:"Kubernetes Client in Java",id:"kubernetes-client-in-java",level:4},{value:"Informers",id:"informers",level:4},{value:"Deployment",id:"deployment",level:4},{value:"Tip 1",id:"tip-1",level:4},{value:"Tip 2",id:"tip-2",level:4},{value:"Tip 3",id:"tip-3",level:4},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h2:"h2",h4:"h4",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["Operators introduced by ",(0,r.jsx)(n.a,{href:"https://www.redhat.com/en/blog/introducing-operators-putting-operational-knowledge-into-software",children:"CoreOS"})," in 2016 are now considered early majority on Categories of Adopters scale."]}),"\n",(0,r.jsx)(n.p,{children:'It means that the technology is becoming pretty mainstream. They use Kubernetes Server API to enforce some operational patterns for a deployment of application. This way application developers can translate the "domain" knowledge to Kubernetes land.'}),"\n",(0,r.jsx)(n.p,{children:'I experimented with them lately, but not enough skills of Go discouraged me at first. But then I realised that I can try to write an Operator in my "mother tonque" - Java. In this post I will share couple of reflections on the topic.'}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"TLDR"})," ",(0,r.jsx)(n.a,{href:"https://github.com/vulture-dominiczek/operator-hello-world",children:"Here"})," is the hello world I wrote."]}),"\n",(0,r.jsx)(n.h2,{id:"anatomy-of-an-operator",children:"Anatomy of an operator"}),"\n",(0,r.jsxs)(n.p,{children:["First and most important of all, ",(0,r.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/extend-kubernetes/operator/",children:"Operator"})," is an extension to Kubernetes. The core idea is to capture what human operator/admin would normally do and encode it in software."]}),"\n",(0,r.jsxs)(n.p,{children:["At some point when Kubernetes was adopted by more and more users there occured an obvious need to extend it's API. A ",(0,r.jsx)(n.strong,{children:"resource"})," in Kubernetes is an endpoint that groups several API objects. That is for example pods resource groups pods and allows actions like ",(0,r.jsx)(n.strong,{children:"get, delete, patch"})," and so on to be acted on them."]}),"\n",(0,r.jsxs)(n.p,{children:["But operators are extension to the system so there must be a way to represent their objectives Kubernetes (declarative) proper way. And there is - ",(0,r.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/",children:"Custom Resources"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"Whenever you write a new Operator, you will want to create custom resource for it. As soon as you register your custom resouce in Kubernetes it will start to serve it from API Server and all actions like get, delete and others will be available. And then your Operator will monitor this new resource and take appropirate actions when desired."}),"\n",(0,r.jsx)(n.h4,{id:"control-loop",children:"Control loop"}),"\n",(0,r.jsxs)(n.p,{children:["Demystification no. 1 is that Operators are nothing new. Kubernetes is driven internally by Controllers. From the definition they implement ",(0,r.jsx)(n.strong,{children:"control loop"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["Funny thing, the term is actually taken from robotics and it is ",(0,r.jsx)(n.em,{children:"nonterminating loop that corrects the state of the system"}),'. What does it mean? For example one simple controller could watch that the certain pod is present in system all the times. Whenever it detects that pod is down it will take steps to restart it and correct the "glitch".']}),"\n",(0,r.jsx)(n.p,{children:"Now, operators are basically the same thing, but as a form of extension. Kubernetes is very permissive when it comes to it's API. So as long as you can reach the Server API (and have rights) then you can do any thing with it. So here is the thing -- operator is a custom controller. But: when it boils down to it's core -- it's just a pod! Like any other. I mean you will probably want to add replication, leader election and so on, but this is still a piece of software with an access to Kubernetes API."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{src:t(5916).A+"",width:"640",height:"196"})}),"\n",(0,r.jsxs)(n.p,{children:["To sum up: operator watches events from the server (it can), or reads the status of current resources and matches that with whats specified in CRD. If there is a mismatch it does ",(0,r.jsx)(n.strong,{children:"reconcillation"}),". This is just another term for control loop. But outside Kubernetes core API."]}),"\n",(0,r.jsx)(n.h4,{id:"kubernetes-client-in-java",children:"Kubernetes Client in Java"}),"\n",(0,r.jsx)(n.p,{children:"Go to solution when dealing in Kubernetes in Java is Fabric8 client. You also want to watch this presentation."}),"\n",(0,r.jsx)(n.p,{children:"You init the client very easily:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"KubernetesClient client = new KubernetesClientBuilder().build();\n"})}),"\n",(0,r.jsx)(n.p,{children:"And then there is a matter of reading the api and ivoking appropirate methods:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'var currentServingDeploymentNullable = client.apps().deployments().inNamespace("default")\n                    .withName("web-serving-app-deployment").get();\nvar currentServingDeployment = Optional.ofNullable(currentServingDeploymentNullable);\n'})}),"\n",(0,r.jsx)(n.h4,{id:"informers",children:"Informers"}),"\n",(0,r.jsx)(n.p,{children:"So, the basic idea is to forever run the control loop, sleep couple of seconds and do everthing again. But this is not the best way to do this. Ideally you would want to only do work when something changes. Actually you can do this easily as well."}),"\n",(0,r.jsx)(n.p,{children:"Kubernetes has a notion of informers. These are WebSocket connections-subscriptions to changes of particular resources. So for example, you could watch all the pods in the namespace for changes and get informed when anything changes at all."}),"\n",(0,r.jsx)(n.p,{children:"This leads to following solution - in the end of reconcillation block on the monitor:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"private static Object changes = new Object();\n...\nsynchronized (changes) {\n    changes.wait();\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Whenever something changes our informer will let us unblock the control loop:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"var handler = new GenericResourceEventHandler<>(update -> {\n    synchronized (changes) {\n        changes.notifyAll();\n    }\n});\n\ncrdClient.inform(handler).start();\n"})}),"\n",(0,r.jsx)(n.p,{children:"The Callback is a little bit bloated so I abstracted it away like so:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"\n\npublic class GenericResourceEventHandler<T> implements ResourceEventHandler<T> {\n\n    private final Consumer<T> handler;\n\n    public GenericResourceEventHandler(Consumer<T> handler) {\n        this.handler = handler;\n    }\n\n\n    @Override\n    public void onAdd(T obj) {\n        this.handler.accept(obj);\n    }\n\n    @Override\n    public void onUpdate(T oldObj, T newObj) {\n        this.handler.accept(newObj);\n    }\n\n    @Override\n    public void onDelete(T obj, boolean deletedFinalStateUnknown) {\n        this.handler.accept(null);\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h4,{id:"deployment",children:"Deployment"}),"\n",(0,r.jsx)(n.p,{children:"So when you are done with the implementation you will probably want to deploy the operator... I wrote it as the Spring Boot application and some interesting stuff happened on the way."}),"\n",(0,r.jsx)(n.h4,{id:"tip-1",children:"Tip 1"}),"\n",(0,r.jsx)(n.p,{children:"You will want to have a private repository, and I chose GHCR. You can set it up and download the passcode. Then create secret for kubernetes:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"kubectl create secret docker-registry regcred \\\n  --docker-server=ghcr.io \\\n  --docker-username=dgawlik \\\n  --docker-password=$GITHUB_TOKEN\n"})}),"\n",(0,r.jsx)(n.h4,{id:"tip-2",children:"Tip 2"}),"\n",(0,r.jsx)(n.p,{children:"You have to create CRD of course. Actually fabric8 client got you covered:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:" <dependency>\n    <groupId>io.fabric8</groupId>\n    <artifactId>kubernetes-client</artifactId>\n    <version>6.13.4</version>\n</dependency>\n<dependency>\n    <groupId>io.fabric8</groupId>\n    <artifactId>crd-generator-apt</artifactId>\n    <version>6.13.4</version>\n    <scope>provided</scope>\n</dependency>\n"})}),"\n",(0,r.jsx)(n.p,{children:"Whenever you create CRD classes it will generate the CRD manifest so you can kubectl apply it. So for example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'\n@Group("com.github.webserving")\n@Version("v1alpha1")\n@ShortNames("websrv")\npublic class WebServingResource extends CustomResource<WebServingSpec, WebServingStatus> implements Namespaced {\n}\n\npublic record WebServingSpec(String page1, String page2) {\n}\n\npublic record WebServingStatus (String status) {\n}\n'})}),"\n",(0,r.jsx)(n.h4,{id:"tip-3",children:"Tip 3"}),"\n",(0,r.jsx)(n.p,{children:"You will want to create native images with GraalVm to speed things up. If you don't have a lot of memory then you can tradeoff the quality of binary for building time/resources."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"<build>\n    <plugins>\n        <plugin>\n            <groupId>org.graalvm.buildtools</groupId>\n            <artifactId>native-maven-plugin</artifactId>\n            <configuration>\n                <buildArgs>\n                    <buildArg>-Ob</buildArg>\n                </buildArgs>\n            </configuration>\n        </plugin>\n        <plugin>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-maven-plugin</artifactId>\n            <configuration>\n                <image>\n                    <publish>true</publish>\n                    <builder>paketobuildpacks/builder-jammy-full:latest</builder>\n                    <name>ghcr.io/dgawlik/webpage-serving:1.0.5</name>\n                    <env>\n                        <BP_JVM_VERSION>21</BP_JVM_VERSION>\n                    </env>\n                </image>\n                <docker>\n                    <publishRegistry>\n                        <url>https://ghcr.io/dgawlik</url>\n                        <username>dgawlik</username>\n                        <password>${env.GITHUB_TOKEN}</password>\n                    </publishRegistry>\n                </docker>\n            </configuration>\n        </plugin>\n    </plugins>\n</build>\n"})}),"\n",(0,r.jsx)(n.p,{children:"And second when you set publish property to true, the package step will automatically push the image to your repositry."}),"\n",(0,r.jsx)(n.p,{children:"The third - you pass -Ob parameter to GraalVM. This will insturct the runtime to do fastest, cheapest build possible. And of course - BP_JVM_VERSION has to be java of your project or things will not work."}),"\n",(0,r.jsxs)(n.p,{children:["And last thing -- if you want debug the container, you will have to choose paketobuildpacks/builder-jammy-full",":latest"," as other buildpacks don't include shell (shame)."]}),"\n",(0,r.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,r.jsx)(n.p,{children:"I haven't covered everything, but everything else is in the repo. The repo is proof of concept that operators in Java are not complicated at all. I would say that even they are easier than in Go. So in the repo you will find following:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"spring-boot static server"}),"\n",(0,r.jsx)(n.li,{children:"operator that watches CRD and mounts config maps in server so that it can serve the websites from the CRD"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"So this basically is Operator hello world."})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},5916:(e,n,t)=>{t.d(n,{A:()=>o});const o=t.p+"assets/images/public_cloud-containers_orchestration-managed_kubernetes-installing-go-operator-images-operator-818e1c5c2f9f798bee5791f086521857.png"},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>s});var o=t(6540);const r={},i=o.createContext(r);function a(e){const n=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),o.createElement(i.Provider,{value:n},e.children)}},98:e=>{e.exports=JSON.parse('{"permalink":"/blog/2024/10/4/","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2024-10-4.md","source":"@site/blog/2024-10-4.md","title":"Writing own Kubernetes operator in Java","description":"Operators introduced by CoreOS in 2016 are now considered early majority on Categories of Adopters scale.","date":"2024-10-04T00:00:00.000Z","tags":[{"inline":true,"label":"k8s","permalink":"/blog/tags/k-8-s"},{"inline":true,"label":"java","permalink":"/blog/tags/java"},{"inline":true,"label":"devops","permalink":"/blog/tags/devops"}],"readingTime":5.865,"hasTruncateMarker":true,"authors":[],"frontMatter":{"title":"Writing own Kubernetes operator in Java","tags":["k8s","java","devops"]},"unlisted":false,"prevItem":{"title":"Topology graphs are important (and fun)","permalink":"/blog/2024/10/26/"}}')}}]);