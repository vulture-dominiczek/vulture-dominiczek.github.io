"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[3214],{7447:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>a,metadata:()=>i,toc:()=>h});var i=n(8701),o=n(4848),s=n(8453);const a={title:"Reflections after writing simple Spring Boot library",tags:["systemdesign","spring","java"]},r="Reflections after writing simple Spring Boot library",l={authorsImageUrls:[]},h=[{value:"The problem",id:"the-problem",level:2},{value:"Approach",id:"approach",level:2},{value:"Reflection",id:"reflection",level:2},{value:"Conclusion",id:"conclusion",level:2}];function c(e){const t={em:"em",h2:"h2",li:"li",p:"p",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.p,{children:(0,o.jsx)(t.em,{children:"Sometimes learning from adversity is better than trying to avoid it.\nTaking it into careful consideration provides valuable lessons that will support you in the future."})}),"\n",(0,o.jsx)(t.p,{children:"I appreciate my job for one particular thing. That is, it provides steady steam of difficult problems that challenge my intellect. Recently I tried to wrap my head around problem how to write tests for semi-large Spring Boot codebase and refactor it (with no tests whatsoever)."}),"\n",(0,o.jsx)(t.p,{children:"I started from the assumption that when you don't have any legacy tests at hand first you write them. How can you know you don't break functionality without running the tests? But the code was very unfriendly and writing them would require writing mocks."}),"\n",(0,o.jsx)(t.p,{children:"So I thought - why not automate stuff a little bit:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"instrument given beans with reflection"}),"\n",(0,o.jsx)(t.li,{children:"dump args and results to json"}),"\n",(0,o.jsx)(t.li,{children:"load json directly in tests instead of writing mocks in plain Java"}),"\n"]}),"\n",(0,o.jsx)(t.h2,{id:"the-problem",children:"The problem"}),"\n",(0,o.jsx)(t.p,{children:"Main problem is that there are absolutely no tests. All testing is done by business. What a terrible waste of time... Each time something changes they click their way through all over again."}),"\n",(0,o.jsx)(t.p,{children:"So I thought I will take snapshot of current state of things and secure some tests in the backend. But there is some many API methods! And each has nested call to service and service calls repository."}),"\n",(0,o.jsx)(t.p,{children:"I would write aspects no problem, but repositories are as you recall interfaces for which the classes are generated by Spring. And to add to that I want to move fast and writing the Advices takes time."}),"\n",(0,o.jsx)(t.p,{children:"I have come up with instrumenting the selected beans, but those beans can autowire another instrumented beans. So some mechanism has to be devised to order the instrumentation to do it from the bottom-most to the top."}),"\n",(0,o.jsx)(t.h2,{id:"approach",children:"Approach"}),"\n",(0,o.jsx)(t.p,{children:'So I have both "special" interfaces of repositories and plain beans annotated as components. Then you have to cater for both of the cases. For the interfaces I generated JDK dynamic proxies. For classes (as it happens they don\'t implement any interface) I used ByteBuddy instrumentation library to subclass them and load them with default classloader.'}),"\n",(0,o.jsx)(t.p,{children:"And I have instrumented beans. Now I unload the old beans and switch them to proxes. For that I used BeanFactory which I took from the ApplicationContext with some class casting. But that is not all beacuse you still have to autowire all affected beans."}),"\n",(0,o.jsx)(t.p,{children:"First iteration of autowiring was very wasteful and boiled down to realoading everything. Then I came to the conclusion to build the dependency graph and updated only the nodes of the graph in reverse order. Spring BeanFactory has both methods for finding bean dependencies and dependants so it was pretty easy. One catch is that you have to actually autowire not the bean itself but the subclassed proxy. After that everything worked as charm."}),"\n",(0,o.jsx)(t.p,{children:"If you are interested you can download the lib here."}),"\n",(0,o.jsx)(t.h2,{id:"reflection",children:"Reflection"}),"\n",(0,o.jsx)(t.p,{children:"After writing the lib and being exposed to the project at work I have some thoughts."}),"\n",(0,o.jsx)(t.p,{children:"First if you write Autoconfig lib to be used by other Spring components you absolutely can't poison the application context with unncessary stuff. If you you put bootstrap.yaml in your library it will float on forever and take predecence and collide with stuff already defined. Spring treats the same multiple bootstraps and in case of name collision the order is random. And if you specify it in config/- directory it will actually take predecence over anything else."}),"\n",(0,o.jsx)(t.p,{children:"Moreover you should not define any components picked up by component scanning as these can clash with other things defined. Just confine everything inside the @AutoConfiguration annotated class with the exception of loading necessary stuff with @Import."}),"\n",(0,o.jsx)(t.p,{children:"Likewise you should not include starters in your library because they will for sure accumulate for several libs. Just use specific non-umbrella deps even better include your own jars."}),"\n",(0,o.jsx)(t.p,{children:"IF you have crosscutting concerns like authentication, you should not use internals outside the pointcuts. So for example you have authentication fetching the token before the feign call. Then using static class for caching the token and pulling it from the business logic is a big mistake."}),"\n",(0,o.jsx)(t.p,{children:"Finally you should have mock database and the whole thing would not be needed. I would just happily write e2e tests then."}),"\n",(0,o.jsx)(t.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,o.jsx)(t.p,{children:"What will be of my little library is yet to be defined. However I learned about some best practices for writing spring boot libs and learned some lessons not to repeat over again. You I am happily sharing it to you by this article."})]})}function d(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>r});var i=n(6540);const o={},s=i.createContext(o);function a(e){const t=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),i.createElement(s.Provider,{value:t},e.children)}},8701:e=>{e.exports=JSON.parse('{"permalink":"/blog/2024/11/5/","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2024-11-5.md","source":"@site/blog/2024-11-5.md","title":"Reflections after writing simple Spring Boot library","description":"*Sometimes learning from adversity is better than trying to avoid it.","date":"2024-11-05T00:00:00.000Z","tags":[{"inline":true,"label":"systemdesign","permalink":"/blog/tags/systemdesign"},{"inline":true,"label":"spring","permalink":"/blog/tags/spring"},{"inline":true,"label":"java","permalink":"/blog/tags/java"}],"readingTime":3.83,"hasTruncateMarker":true,"authors":[],"frontMatter":{"title":"Reflections after writing simple Spring Boot library","tags":["systemdesign","spring","java"]},"unlisted":false,"prevItem":{"title":"Thoughts on observability","permalink":"/blog/2024/12/15/"},"nextItem":{"title":"1BRC Challenge","permalink":"/blog/2024/10/29/"}}')}}]);