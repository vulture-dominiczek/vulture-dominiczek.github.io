"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[3574],{2219:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>p,frontMatter:()=>a,metadata:()=>o,toc:()=>h});var o=t(949),s=t(4848),i=t(8453);const a={title:"Topology graphs are important (and fun)",tags:["k8s","openshift"]},r="Topology graphs are important (and fun)",l={authorsImageUrls:[]},h=[{value:"Topology view in OpenShift",id:"topology-view-in-openshift",level:2},{value:"What&#39;s under the hood",id:"whats-under-the-hood",level:3},{value:"Kubernetes standard labels/annotations",id:"kubernetes-standard-labelsannotations",level:2}];function d(e){const n={code:"code",h2:"h2",h3:"h3",img:"img",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:'Recently I watched the presentation from Microsoft about Radius. They developed the tool to foster the collaboration between devops and developers. In nutshell devops create "recipies" in Bicep or Terraform and developers use them to deploy the application. Seems cool.'}),"\n",(0,s.jsx)(n.p,{children:"However this is not the topic for this article. They mentioned the idea that instantly clicked in my head. That is - we waste so much of our time when interacting with kubernetes. Imagine you want to learn why app is not working and you know that it depends on \"downstream\" app. So you start with the deployment, it's fine, then you go to the code and find out the k8s service name that it's using. Then by labels or simply by name you find the dependent deployment that is failing. So we had 3 context switches. What about the dependencies that are > 2 links deep?"}),"\n",(0,s.jsx)(n.p,{children:"Exactly this is just too much work. There is a better way to handle things. We draw graph where deployments are nodes and edges are dependencies. This was briefly mentioned in the presentation however it was not main topic. But the concept is not new. Openshift as much as I was able to reasearch had it 5 years ago already."}),"\n",(0,s.jsx)(n.h2,{id:"topology-view-in-openshift",children:"Topology view in OpenShift"}),"\n",(0,s.jsx)(n.p,{children:"One picture worth thousand of words:"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{src:t(258).A+"",width:"1337",height:"670"})}),"\n",(0,s.jsx)(n.p,{children:"What if the postres went down? Then it would look like this:"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{src:t(1225).A+"",width:"198",height:"182"})}),"\n",(0,s.jsx)(n.p,{children:"I mean not exactly, it would be rounded in red circle, but you get the picture. You can instantly see."}),"\n",(0,s.jsx)(n.p,{children:"What is more you can view its code with Eclipse Che by deploying own workspace. Committing changes with git is whole different story..."}),"\n",(0,s.jsx)(n.h3,{id:"whats-under-the-hood",children:"What's under the hood"}),"\n",(0,s.jsx)(n.p,{children:"I clicked away all this in OpenShift but the real use case would be deploying apps with helm. So how is it done?"}),"\n",(0,s.jsx)(n.p,{children:"As it turns out these are just plain labels and annotations."}),"\n",(0,s.jsx)(n.p,{children:"First the simple stuff:"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{src:t(6752).A+"",width:"178",height:"169"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:'How would you get the "Go" picture? Very simple:'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"kubectl label deployments go-basic app.openshift.io/runtime=golang\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"How would you group applications together?"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"kubectl label deployments go-basic app.kubernetes.io/part-of=sample-app\nkubectl label deployments frontend app.kubernetes.io/part-of=sample-app\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"How would you get the dependency-arrows?"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'kubectl annotate deployments frontend \'app.openshift.io/connects-to=[{"apiVersion":"apps/v1","kind":"Deployment","name":"go-basic"}\n'})}),"\n",(0,s.jsx)(n.p,{children:"So there is no magic here. These are just plain labels and annotations and the beauty is that they don't even interfere with your workflow."}),"\n",(0,s.jsx)(n.h2,{id:"kubernetes-standard-labelsannotations",children:"Kubernetes standard labels/annotations"}),"\n",(0,s.jsx)(n.p,{children:"Kubernetes standard labels/annotations"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"app.kubernetes.io/name"})}),"\n",(0,s.jsx)(n.p,{children:"This is the name of the application"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"app.kubernetes.io/instance"})}),"\n",(0,s.jsx)(n.p,{children:"This is the name of the replica/instance in case you have many applications. You can think of it as blueprint - object pattern."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"app.kubernetes.io/version"})}),"\n",(0,s.jsx)(n.p,{children:"No explanation needed"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"app.kubernetes.io/component"})}),"\n",(0,s.jsx)(n.p,{children:"Not sure what this does, but probably some categorization backend versus frontend."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"app.kubernetes.io/part-of"})}),"\n",(0,s.jsx)(n.p,{children:"We have seen it that it groups apps in OpenShift."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"app.kubernetes.io/managed-by"})}),"\n",(0,s.jsx)(n.p,{children:"I would recommend avoiding it, as it interferes with OpenShift topology rendering."}),"\n",(0,s.jsx)(n.p,{children:"What you could do in couple of minutes, you can do in seconds. Viewing graphs instead of list of resources enables you to debug the system faster and hassle free."})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},258:(e,n,t)=>{t.d(n,{A:()=>o});const o=t.p+"assets/images/scshot-1-19ec64f5808ce7319aa9118cd1c8fc63.png"},1225:(e,n,t)=>{t.d(n,{A:()=>o});const o=t.p+"assets/images/scshot-2-43acdece9487f0dc149b1baf7e3ab406.png"},6752:(e,n,t)=>{t.d(n,{A:()=>o});const o=t.p+"assets/images/scshot-3-cae90e7495ec629724aaf8728eca9371.png"},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>r});var o=t(6540);const s={},i=o.createContext(s);function a(e){const n=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),o.createElement(i.Provider,{value:n},e.children)}},949:e=>{e.exports=JSON.parse('{"permalink":"/blog/2024/10/26/","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2024-10-26.md","source":"@site/blog/2024-10-26.md","title":"Topology graphs are important (and fun)","description":"Recently I watched the presentation from Microsoft about Radius. They developed the tool to foster the collaboration between devops and developers. In nutshell devops create \\"recipies\\" in Bicep or Terraform and developers use them to deploy the application. Seems cool.","date":"2024-10-26T00:00:00.000Z","tags":[{"inline":true,"label":"k8s","permalink":"/blog/tags/k-8-s"},{"inline":true,"label":"openshift","permalink":"/blog/tags/openshift"}],"readingTime":2.52,"hasTruncateMarker":true,"authors":[],"frontMatter":{"title":"Topology graphs are important (and fun)","tags":["k8s","openshift"]},"unlisted":false,"prevItem":{"title":"1BRC Challenge","permalink":"/blog/2024/10/29/"},"nextItem":{"title":"Writing own Kubernetes operator in Java","permalink":"/blog/2024/10/4/"}}')}}]);